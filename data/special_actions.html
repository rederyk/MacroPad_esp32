<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MacroPad ¬∑ Special Actions</title>
    <link
      rel="icon"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiByeD0iMTIiIGZpbGw9IiMwZTYzOWMiLz48dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1zaXplPSIzMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZmZmZiIgZm9udC1mYW1pbHk9IlNlZ29lIFVJLCBBcmlhbCwgc2Fucy1zZXJpZiI+TTwvdGV4dD48L3N2Zz4K"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link rel="stylesheet" href="/ui/app.css" />
    <style>
      .tab-nav {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .tab-button {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-secondary);
        padding: 10px 18px;
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .tab-button.active,
      .tab-button:hover {
        background-color: var(--accent);
        color: #fff;
        border-color: transparent;
      }
      .panel {
        display: none;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
      }
      .panel.active {
        display: block;
      }
      .panel-heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }
      .panel-heading .card-title {
        margin: 0;
      }
      .panel-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
      }
      .card {
        background-color: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .card-subtitle {
        margin: 0;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }
      .simple-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.88rem;
      }
      .simple-table thead {
        background-color: rgba(255, 255, 255, 0.04);
      }
      .simple-table th,
      .simple-table td {
        text-align: left;
        padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        vertical-align: top;
      }
      .simple-table tbody tr:hover {
        background-color: rgba(255, 255, 255, 0.03);
      }
      .stacked {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.75rem;
        border: 1px solid transparent;
      }
      .badge.success {
        background: rgba(14, 122, 58, 0.15);
        color: #4fe49c;
        border-color: rgba(14, 122, 58, 0.4);
      }
      .badge.error {
        background: rgba(161, 38, 13, 0.15);
        color: #ff9070;
        border-color: rgba(161, 38, 13, 0.4);
      }
      .badge.info {
        background: rgba(14, 99, 156, 0.15);
        color: #7bc6ff;
        border-color: rgba(14, 99, 156, 0.4);
      }
      .muted {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }
      .list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 320px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.02);
      }
      .list-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid transparent;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .list-item:hover {
        background-color: rgba(14, 99, 156, 0.18);
        border-color: rgba(14, 99, 156, 0.4);
      }
      .list-item.active {
        background-color: rgba(14, 99, 156, 0.28);
        border-color: rgba(14, 99, 156, 0.6);
      }
      .flex-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
      }
      .flex-row.stretch > * {
        flex: 1;
      }
      .form-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label {
        font-weight: 500;
        color: var(--text-secondary);
      }
      input[type="text"],
      input[type="number"],
      select,
      textarea {
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 10px 12px;
        color: var(--text-primary);
        font-size: 0.95rem;
      }
      input[type="text"]:focus,
      input[type="number"]:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.35);
      }
      textarea {
        min-height: 140px;
        resize: vertical;
      }
      .actions-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .primary-btn,
      .secondary-btn,
      .danger-btn {
        border: none;
        border-radius: 6px;
        padding: 10px 16px;
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .primary-btn {
        background-color: var(--accent);
        color: #fff;
      }
      .primary-btn:disabled {
        background-color: rgba(14, 99, 156, 0.35);
        cursor: not-allowed;
      }
      .primary-btn:hover:not(:disabled) {
        background-color: var(--accent-hover);
      }
      .secondary-btn {
        background-color: rgba(255, 255, 255, 0.08);
        color: var(--text-primary);
      }
      .secondary-btn:hover {
        background-color: rgba(255, 255, 255, 0.15);
      }
      .danger-btn {
        background-color: var(--danger);
        color: #fff;
      }
      .danger-btn:hover {
        background-color: var(--danger-hover);
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background-color: rgba(255, 255, 255, 0.04);
        border: 1px solid var(--border-color);
        font-size: 0.85rem;
      }
      .hidden {
        display: none !important;
      }
      .guided-status {
        margin-top: 10px;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }
      .guided-feedback {
        margin-top: 14px;
        padding: 12px;
        border-radius: 8px;
        border: 1px dashed var(--border-color);
        background-color: rgba(14, 99, 156, 0.08);
      }
      .guided-history {
        margin-top: 14px;
        max-height: 260px;
        overflow-y: auto;
      }
      .guided-history-entry {
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        margin-bottom: 8px;
        background-color: rgba(255, 255, 255, 0.02);
      }
      .guided-history-entry strong {
        display: block;
      }
      .guided-history-entry.success {
        border-color: rgba(14, 122, 58, 0.4);
        background-color: rgba(14, 122, 58, 0.1);
      }
      .guided-history-entry.error {
        border-color: rgba(161, 38, 13, 0.4);
        background-color: rgba(161, 38, 13, 0.08);
      }
      .guided-history-entry.pending {
        border-color: rgba(14, 99, 156, 0.4);
        background-color: rgba(14, 99, 156, 0.08);
      }
      @media (max-width: 720px) {
        .panel-grid {
          grid-template-columns: 1fr;
        }
        .simple-table {
          font-size: 0.82rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <header class="app-header">
        <div class="branding">
          <i class="fas fa-bolt"></i>
          <span>MacroPad ¬∑ Special Actions</span>
        </div>
        <div class="header-status">
          <div class="status-chip">
            <i class="fas fa-list-check"></i>
            <span>Azioni:</span>
            <span id="actionsCount">0</span>
          </div>
          <div class="status-chip">
            <i class="fas fa-link"></i>
            <span>Endpoint base:</span>
            <span id="endpointBase">/special_action</span>
          </div>
        </div>
      </header>

      <nav class="tab-nav">
        <button class="tab-button active" data-tab-target="tab-actions">
          <i class="fas fa-bolt"></i> Azioni rapide
        </button>
        <button class="tab-button" data-tab-target="tab-ir">
          <i class="fas fa-wave-square"></i> Gestione comandi IR
        </button>
        <button class="tab-button" data-tab-target="tab-irscan">
          <i class="fas fa-broadcast-tower"></i> IR Scan
        </button>
      </nav>

      <section class="panel active" id="tab-actions">
        <div class="panel-heading">
          <div>
            <h2 class="card-title">
              <i class="fas fa-wrench me-2"></i>Catalogo azioni
            </h2>
            <p class="card-subtitle">
              Richiami rapidi e operazioni avanzate sul dispositivo.
            </p>
          </div>
          <div class="actions-bar">
            <button class="secondary-btn" id="reloadActions">
              <i class="fas fa-sync-alt"></i>Ricarica elenco
            </button>
          </div>
        </div>
        <div class="data-columns actions-layout">
          <div class="data-column">
            <div class="panel-grid">
              <article class="card" style="grid-column: 1 / -1;">
                <div class="actions-grid" id="actionCatalog">
                  <div class="loading-state">Caricamento azioni...</div>
                </div>
              </article>
            </div>
          </div>
          <div class="data-column">
            <article class="card">
              <div class="card-header">
                <div>
                  <h3 class="card-title">
                    <i class="fas fa-terminal me-2"></i>Stream log
                  </h3>
                  <p class="card-subtitle">
                    Monitor live degli eventi inviati dal dispositivo.
                  </p>
                </div>
                <div class="actions-bar">
                  <button class="secondary-btn" id="logsReconnect">
                    <i class="fas fa-sync-alt"></i>Riconnetti
                  </button>
                  <button class="secondary-btn" id="logsClear">
                    <i class="fas fa-broom"></i>Pulisci
                  </button>
                </div>
              </div>
              <div class="logs-container">
                <div class="logs-header">
                  <h5>EventSource /log</h5>
                </div>
                <div id="logStream"></div>
              </div>
            </article>
          </div>
        </div>
      </section>

      <section class="panel" id="tab-ir">
        <div class="panel-heading">
          <div>
            <h2 class="card-title">
              <i class="fas fa-remote"></i>Gestione database IR
            </h2>
            <p class="card-subtitle">
              Consulta i comandi salvati sul dispositivo, esplora il database
              irdb e importa rapidamente i tasti.
            </p>
          </div>
          <div class="chip">
            <i class="fas fa-database"></i>
            <span id="irDirtyStatus" class="muted">Nessuna modifica</span>
          </div>
        </div>
        <div class="panel-grid">
          <article class="card" id="irLocalCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-save"></i>Archivio locale
                </h3>
                <p class="card-subtitle">
                  Gestisci i dispositivi e i comandi salvati in
                  <code>/ir_data.json</code>.
                </p>
              </div>
              <button class="secondary-btn" id="irReloadLocal">
                <i class="fas fa-sync-alt"></i>Ricarica
              </button>
            </div>
            <div class="form-group">
              <label for="irDeviceSelect">Dispositivo</label>
              <select id="irDeviceSelect"></select>
            </div>
            <div class="actions-bar">
              <button class="secondary-btn" id="irAddDevice">
                <i class="fas fa-plus"></i>Nuovo dispositivo
              </button>
              <button class="secondary-btn" id="irRenameDevice">
                <i class="fas fa-i-cursor"></i>Rinomina
              </button>
              <button class="danger-btn" id="irDeleteDevice">
                <i class="fas fa-trash"></i>Elimina
              </button>
            </div>
            <div>
              <div class="flex-row">
                <span class="muted"
                  >Comandi registrati: <strong id="irCommandCount">0</strong></span
                >
                <span class="muted"
                  >Dimensione stimata:
                  <strong id="irEstimatedSize">0 B</strong></span
                >
              </div>
            </div>
            <div id="irCommandsContainer">
              <div class="muted">Seleziona un dispositivo per vedere i comandi.</div>
            </div>
            <div class="actions-bar">
              <button class="primary-btn" id="irSaveChanges" disabled>
                <i class="fas fa-cloud-upload-alt"></i>Salva su dispositivo
              </button>
            </div>
          </article>

          <article class="card" id="irdbSearchCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-search"></i>Libreria irdb
                </h3>
                <p class="card-subtitle">
                  Consulta il catalogo <strong>irdb</strong> direttamente dal
                  tuo browser.
                </p>
              </div>
              <button class="secondary-btn" id="irdbLoadIndex">
                <i class="fas fa-download"></i>Carica indice
              </button>
            </div>
            <div class="form-group">
              <label for="irdbSearchInput">Filtra per produttore, categoria o modello</label>
              <input
                type="text"
                id="irdbSearchInput"
                placeholder="Es. Samsung TV, Sony, Receiver..."
              />
            </div>
            <div class="muted">
              <span id="irdbIndexStatus">Indice non caricato.</span>
            </div>
            <div class="list" id="irdbResults">
              <div class="muted">Premi "Carica indice" per iniziare.</div>
            </div>
          </article>

          <article class="card" id="irdbDatasetCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-table"></i>Dettaglio dataset
                </h3>
                <p class="card-subtitle">
                  Analizza i comandi e importali in un dispositivo locale.
                </p>
              </div>
              <span class="badge info" id="irdbDatasetBadge">Nessun dataset selezionato</span>
            </div>
            <div class="stacked">
              <div class="flex-row stretch">
                <div class="form-group" style="flex: 1;">
                  <label for="irdbTargetDevice">Importa in dispositivo</label>
                  <select id="irdbTargetDevice"></select>
                </div>
                <div class="form-group" style="flex: 1;">
                  <label for="irdbNewDeviceName">...oppure crea nuovo</label>
                  <input
                    type="text"
                    id="irdbNewDeviceName"
                    placeholder="Es. tv_soggiorno"
                  />
                </div>
              </div>
              <div class="flex-row">
                <button class="primary-btn" id="irdbImportSelected">
                  <i class="fas fa-file-import"></i>Importa selezionati
                </button>
                <span class="muted" id="irdbSelectionSummary">0 comandi selezionati.</span>
              </div>
            </div>
            <div id="irdbCommandsContainer">
              <div class="muted">
                Seleziona un dataset nella libreria irdb per visualizzare i
                comandi disponibili.
              </div>
            </div>
          </article>

          <article class="card" id="irGuidedCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-magic"></i>Modalit√† guidata telecomando
                </h3>
                <p class="card-subtitle">
                  Seleziona il tipo di dispositivo, prova automaticamente i codici e mappa solo quelli che funzionano.
                </p>
              </div>
              <span class="badge info" id="guidedStatusBadge">Inattiva</span>
            </div>

            <div class="stacked">
              <div class="form-group">
                <label for="guidedDeviceType">Tipo dispositivo</label>
                <select id="guidedDeviceType">
                  <option value="tv">TV / Monitor</option>
                  <option value="led">Striscia LED / Illuminazione</option>
                  <option value="settop">Decoder / Set-top box</option>
                  <option value="audio">Soundbar / Audio</option>
                  <option value="projector">Proiettore</option>
                  <option value="ac">Climatizzatore</option>
                </select>
              </div>
              <div class="form-group">
                <label for="guidedBrand">Marca</label>
                <select id="guidedBrand">
                  <option value="">Carica l'indice irdb per iniziare</option>
                </select>
                <span class="muted" id="guidedBrandHint">Premi ‚ÄúCarica indice‚Äù se l'elenco √® vuoto.</span>
              </div>
              <div class="flex-row stretch">
                <div class="form-group" style="flex: 1;">
                  <label for="guidedTargetDevice">Dispositivo locale</label>
                  <select id="guidedTargetDevice"></select>
                </div>
                <div class="form-group" style="flex: 1;">
                  <label for="guidedNewDevice">...oppure crea nuovo</label>
                  <input type="text" id="guidedNewDevice" placeholder="es. tv_salone" />
                </div>
              </div>
              <div class="actions-bar">
                <button class="primary-btn" id="guidedStart">
                  <i class="fas fa-magic"></i>Avvia procedura
                </button>
                <button class="secondary-btn" id="guidedStop" disabled>
                  <i class="fas fa-stop-circle"></i>Ferma
                </button>
                <button class="secondary-btn" id="guidedLoadIndex">
                  <i class="fas fa-database"></i>Carica indice irdb
                </button>
              </div>
            </div>

            <div class="guided-status" id="guidedStatus">
              Seleziona tipo, marca e dispositivo locale per avviare il test guidato.
            </div>

            <div class="guided-feedback hidden" id="guidedFeedback">
              <div class="muted">
                Sto inviando automaticamente i comandi dal dataset
                <strong id="guidedDatasetLabel">‚Äî</strong>. Appena il dispositivo reagisce, premi
                <em>"Il dispositivo ha risposto"</em> per bloccare la ricerca e importare la mappatura corretta.
              </div>
              <div class="guided-status" id="guidedCurrentCommand">Ultimo comando: ‚Äî</div>
              <div class="muted" style="margin-top: 8px; font-size: 0.9em;">
                ü§ñ <strong>Modalit√† RICORSIVA AUTOMATICA:</strong> Il sistema tester√† tutti i dataset compatibili (max 8 comandi/dataset, priorit√† ‚â•70).
                Auto-skip dopo 8 comandi senza risposta. Continua finch√© non trovi il dispositivo o finiscono i dataset. Intervallo: 400ms.
              </div>
              <div class="actions-bar">
                <button class="primary-btn" id="guidedFeedbackYes">
                  <i class="fas fa-check"></i>Il dispositivo ha risposto
                </button>
                <button class="secondary-btn" id="guidedFeedbackNo">
                  <i class="fas fa-forward"></i>Nessuna risposta (avanti)
                </button>
                <button class="secondary-btn" id="guidedFeedbackSkip">
                  <i class="fas fa-forward-fast"></i>Salta marca/dataset
                </button>
              </div>
            </div>

            <div class="guided-history list" id="guidedHistory">
              <div class="muted">Nessun test avviato.</div>
            </div>
          </article>

          <!-- Card identificazione rimossa - spostata nel tab IR Scan -->

          <article class="card" id="irManualCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-keyboard"></i>Inserimento manuale
                </h3>
                <p class="card-subtitle">
                  Aggiungi rapidamente un comando compilando protocollo, valore
                  e bit.
                </p>
              </div>
            </div>
            <form id="irManualForm" class="stacked">
              <div class="form-group">
                <label for="irManualName">Nome comando</label>
                <input
                  type="text"
                  id="irManualName"
                  placeholder="Es. power_on"
                  required
                />
              </div>
              <div class="flex-row stretch">
                <div class="form-group" style="flex: 1;">
                  <label for="irManualProtocol">Protocollo</label>
                  <select id="irManualProtocol" required>
                    <option value="">Seleziona...</option>
                    <option value="NEC">NEC</option>
                    <option value="NECx2">NECx2</option>
                    <option value="NEC2">NEC2</option>
                    <option value="SONY">SONY</option>
                    <option value="SAMSUNG">SAMSUNG</option>
                    <option value="RC5">RC5</option>
                    <option value="RAW">RAW</option>
                  </select>
                </div>
                <div class="form-group" style="flex: 1;">
                  <label for="irManualBits">Bit</label>
                  <input
                    type="number"
                    id="irManualBits"
                    value="32"
                    min="1"
                    max="64"
                    required
                  />
                </div>
              </div>
              <div class="form-group">
                <label for="irManualValue">Valore HEX (per RAW lascia vuoto)</label>
                <input
                  type="text"
                  id="irManualValue"
                  placeholder="es. e0e040bf"
                />
              </div>
              <div class="form-group">
                <label for="irManualRaw">RAW (microsecondi separati da virgola)</label>
                <textarea
                  id="irManualRaw"
                  placeholder="Esempio: 9000,4500,560,560,560,560..."
                ></textarea>
              </div>
              <div class="actions-bar">
                <button class="primary-btn" type="submit">
                  <i class="fas fa-plus-circle"></i>Aggiungi al dispositivo selezionato
                </button>
              </div>
            </form>
            <p class="muted">
              Suggerimento: puoi sempre usare la
              <strong>macro IR_SCAN</strong> sul dispositivo per acquisire nuovi
              comandi e poi assegnare un nome dalla tastiera o dalla gesture.
            </p>
          </article>
        </div>
      </section>

      <section class="panel" id="tab-irscan">
        <div class="panel-heading">
          <div>
            <h2 class="card-title">
              <i class="fas fa-broadcast-tower"></i>Acquisizione comandi IR
            </h2>
            <p class="card-subtitle">
              Registra comandi IR direttamente dal ricevitore e salvali nel dispositivo.
            </p>
          </div>
          <div class="chip">
            <i class="fas fa-wifi"></i>
            <span id="scanStatus" class="muted">Pronto</span>
          </div>
        </div>

        <div class="panel-grid">
          <article class="card">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-satellite-dish"></i>Modalit√† acquisizione
                </h3>
                <p class="card-subtitle">
                  Avvia l'acquisizione e premi i tasti del telecomando
                </p>
              </div>
              <span class="badge info" id="scanModeBadge">Inattivo</span>
            </div>

            <div class="form-group">
              <label for="scanTargetDevice">Dispositivo di destinazione</label>
              <div class="flex-row stretch">
                <select id="scanTargetDevice" style="flex: 2;"></select>
                <input
                  type="text"
                  id="scanNewDeviceName"
                  placeholder="Nuovo dispositivo..."
                  style="flex: 1;"
                />
              </div>
            </div>

            <div class="actions-bar">
              <button class="primary-btn" id="startScanMode">
                <i class="fas fa-play"></i>Avvia acquisizione
              </button>
              <button class="danger-btn" id="stopScanMode" disabled>
                <i class="fas fa-stop"></i>Ferma
              </button>
            </div>

            <div id="scanInstructions" class="muted" style="margin-top: 15px;">
              Seleziona un dispositivo di destinazione e avvia l'acquisizione.
              Ogni codice IR ricevuto verr√† mostrato qui sotto.
            </div>
          </article>

          <article class="card">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-list"></i>Codici acquisiti
                </h3>
                <p class="card-subtitle">
                  Lista dei comandi IR ricevuti durante la scansione
                </p>
              </div>
              <span class="badge info" id="scannedCountBadge">0 codici</span>
            </div>

            <div id="scannedCodesContainer" class="list" style="max-height: 400px;">
              <div class="muted">Nessun codice acquisito. Avvia la scansione.</div>
            </div>

            <div class="actions-bar">
              <button class="secondary-btn" id="clearScannedCodes">
                <i class="fas fa-broom"></i>Svuota lista
              </button>
              <button class="primary-btn" id="saveScannedCodes" disabled>
                <i class="fas fa-save"></i>Salva tutti nel dispositivo
              </button>
            </div>
          </article>

          <article class="card" id="irIdentificationCard">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-fingerprint"></i>Identificazione automatica IRDB
                </h3>
                <p class="card-subtitle">
                  Trova automaticamente il dataset IRDB migliore per i tuoi codici
                </p>
              </div>
              <span class="badge info" id="identificationBadge">Pronto</span>
            </div>

            <div class="form-group">
              <label>Come identificare il dispositivo</label>
              <div class="flex-row">
                <button class="secondary-btn" id="identifyFromScan" title="Usa i codici acquisiti sopra per trovare il dataset">
                  <i class="fas fa-radar"></i>Usa codici acquisiti
                </button>
                <button class="secondary-btn" id="identifyFromProfile" title="Usa i comandi gi√† salvati per identificare il dataset">
                  <i class="fas fa-chart-bar"></i>Usa comandi salvati
                </button>
              </div>
            </div>

            <div id="identificationStatus" class="muted">
              Acquisisci almeno 2-3 codici IR e poi clicca "Usa codici acquisiti" per identificare automaticamente il dataset IRDB migliore.
            </div>

            <div id="identificationResults">
              <!-- Popolato dinamicamente con i risultati -->
            </div>
          </article>

          <article class="card" id="customRemoteCard" style="grid-column: 1 / -1;">
            <div class="card-header">
              <div>
                <h3 class="card-title">
                  <i class="fas fa-gamepad"></i>Telecomando Personalizzato
                </h3>
                <p class="card-subtitle">
                  Crea telecomandi personalizzati con layout specifici per TV, LED, Clima o Audio
                </p>
              </div>
              <span class="badge info" id="customRemoteBadge">Configurazione</span>
            </div>

            <div class="flex-row" style="gap: 12px; margin-bottom: 16px;">
              <div class="form-group" style="flex: 2;">
                <label for="remoteDeviceSelect">Dispositivo sorgente comandi IR</label>
                <select id="remoteDeviceSelect">
                  <option value="">-- Seleziona dispositivo --</option>
                </select>
              </div>
              <div class="form-group" style="flex: 1;">
                <label for="remoteType">Tipo telecomando</label>
                <select id="remoteType">
                  <option value="tv">TV</option>
                  <option value="led">LED Strip</option>
                  <option value="clima">Climatizzatore</option>
                  <option value="audio">Audio/Receiver</option>
                  <option value="custom">Personalizzato</option>
                </select>
              </div>
            </div>

            <div class="actions-bar" style="margin-bottom: 20px;">
              <button class="primary-btn" id="createRemoteBtn">
                <i class="fas fa-plus-circle"></i>Crea nuovo telecomando
              </button>
              <button class="secondary-btn" id="loadRemoteBtn">
                <i class="fas fa-folder-open"></i>Carica configurazione
              </button>
              <button class="secondary-btn" id="saveRemoteBtn" disabled>
                <i class="fas fa-save"></i>Salva configurazione
              </button>
            </div>

            <div id="remoteBuilderContainer" style="display: none;">
              <div style="border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; background-color: rgba(255, 255, 255, 0.02);">
                <div class="card-header" style="margin-bottom: 20px;">
                  <h4 class="card-title" style="margin: 0;">
                    <i class="fas fa-edit"></i>Editor Telecomando - <span id="remoteTypeName">TV</span>
                  </h4>
                  <div class="actions-bar">
                    <button class="secondary-btn" id="addCustomButton">
                      <i class="fas fa-plus"></i>Aggiungi tasto
                    </button>
                    <button class="secondary-btn" id="resetRemoteLayout">
                      <i class="fas fa-undo"></i>Reset layout
                    </button>
                  </div>
                </div>

                <div style="margin-bottom: 12px; padding: 10px; background-color: rgba(14, 99, 156, 0.15); border-radius: 6px; border-left: 3px solid var(--accent);">
                  <div style="font-size: 0.85rem; color: var(--text-secondary);">
                    <strong><i class="fas fa-info-circle"></i> Come usare:</strong>
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                      <li>Clicca un tasto per selezionarlo e configurarlo</li>
                      <li>Tasti con bordo verde hanno comandi associati</li>
                      <li><strong>Ctrl+Click</strong> su tasto con comando per inviarlo</li>
                    </ul>
                  </div>
                </div>

                <div id="remotePreview" style="max-width: 400px; margin: 0 auto; background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); border-radius: 20px; padding: 30px 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
                  <!-- Il layout del telecomando verr√† generato dinamicamente qui -->
                </div>

                <div style="margin-top: 20px;">
                  <h5 class="card-title" style="margin-bottom: 12px;">
                    <i class="fas fa-link"></i>Binding Comandi
                  </h5>
                  <p class="muted" style="margin-bottom: 12px;">
                    Clicca su un tasto del telecomando sopra, poi seleziona il comando IR da associare
                  </p>
                  <div id="bindingPanel" style="display: none; border: 1px solid var(--accent); border-radius: 8px; padding: 16px; background-color: rgba(14, 99, 156, 0.1);">
                    <div style="margin-bottom: 12px;">
                      <strong>Tasto selezionato:</strong> <span id="selectedButtonName">-</span>
                    </div>
                    <div class="form-group">
                      <label for="bindCommandSelect">Comando IR da associare</label>
                      <select id="bindCommandSelect">
                        <option value="">-- Nessun comando --</option>
                      </select>
                    </div>
                    <div class="actions-bar" style="margin-top: 12px;">
                      <button class="primary-btn" id="bindCommandBtn">
                        <i class="fas fa-link"></i>Associa comando
                      </button>
                      <button class="secondary-btn" id="testRemoteCommandBtn">
                        <i class="fas fa-paper-plane"></i>Invia test
                      </button>
                      <button class="secondary-btn" id="unbindCommandBtn">
                        <i class="fas fa-unlink"></i>Rimuovi
                      </button>
                      <button class="secondary-btn" id="learnCommandBtn">
                        <i class="fas fa-satellite-dish"></i>Impara nuovo
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div id="savedRemotesContainer" style="margin-top: 20px;">
              <h5 class="card-title" style="margin-bottom: 12px;">
                <i class="fas fa-list"></i>Telecomandi Salvati
              </h5>
              <div id="savedRemotesList" class="list">
                <div class="muted">Nessun telecomando salvato. Crea il tuo primo telecomando!</div>
              </div>
            </div>
          </article>
        </div>
      </section>
    </div>

    <div class="toast" id="toast"></div>

    <script>
      (() => {
        "use strict";
        try {
          const IRDB_INDEX_URL = "https://cdn.jsdelivr.net/gh/probonopd/irdb@master/index";
          const IRDB_CODES_BASE_URL = "https://cdn.jsdelivr.net/gh/probonopd/irdb@master/";
          const MAX_IRDB_RESULTS = 200;

          const state = {
            actions: [],
            payloadTemplates: {},
            eventSource: null,
            activeTab: "tab-actions",
            ir: {
              devices: {},
              original: {},
              selectedDevice: "",
              dirty: false,
              initialized: false,
            },
            irdb: {
              index: [],
              filtered: [],
              loadingIndex: false,
              indexError: "",
              selectedEntry: null,
              csv: [],
              csvLoading: false,
              csvError: "",
              selection: new Set(),
            },
            guided: {
              active: false,
              busy: false,
              deviceType: "tv",
              brand: "",
              targetDevice: "",
              queue: [],
              candidates: [],
              allCandidates: [],
              currentCandidateIndex: -1,
              lockedEntryPath: "",
              currentCommand: null,
              currentHistoryId: "",
              history: [],
              mappedCount: 0,
              datasetCache: {},
              testedCommands: new Set(),
              loopHandle: null,
              activeDatasetPath: "",
              commandsTested: 0,
              datasetCommandCounter: 0,
            },
            irFingerprinting: {
              localFingerprints: [],
              deviceProfile: {
                protocol: {},
                addresses: {},
                confidence: 0,
              },
              matches: [],
              testResults: {},
              scanning: false,
              scannedCodes: [],
              identifying: false,
            },
            irScan: {
              active: false,
              targetDevice: "",
              scannedCodes: [],
            },
            customRemote: {
              currentRemote: null,
              remoteType: "tv",
              sourceDevice: "",
              buttons: {},
              selectedButton: null,
              savedRemotes: [],
              learningActive: false,
            },
          };

          const dom = {
            toast: document.getElementById("toast"),
            actionContainer: document.getElementById("actionCatalog"),
            actionsCount: document.getElementById("actionsCount"),
            endpointBase: document.getElementById("endpointBase"),
            reloadActions: document.getElementById("reloadActions"),
            logsReconnect: document.getElementById("logsReconnect"),
            logsClear: document.getElementById("logsClear"),
            logStream: document.getElementById("logStream"),
            tabButtons: Array.from(document.querySelectorAll(".tab-button")),
            panels: Array.from(document.querySelectorAll(".panel")),
            irDirtyStatus: document.getElementById("irDirtyStatus"),
            irReloadLocal: document.getElementById("irReloadLocal"),
            irDeviceSelect: document.getElementById("irDeviceSelect"),
            irAddDevice: document.getElementById("irAddDevice"),
            irRenameDevice: document.getElementById("irRenameDevice"),
            irDeleteDevice: document.getElementById("irDeleteDevice"),
            irCommandCount: document.getElementById("irCommandCount"),
            irEstimatedSize: document.getElementById("irEstimatedSize"),
            irCommandsContainer: document.getElementById("irCommandsContainer"),
            irSaveChanges: document.getElementById("irSaveChanges"),
            irdbLoadIndex: document.getElementById("irdbLoadIndex"),
            irdbSearchInput: document.getElementById("irdbSearchInput"),
            irdbIndexStatus: document.getElementById("irdbIndexStatus"),
            irdbResults: document.getElementById("irdbResults"),
            irdbDatasetBadge: document.getElementById("irdbDatasetBadge"),
            irdbTargetDevice: document.getElementById("irdbTargetDevice"),
            irdbNewDevice: document.getElementById("irdbNewDeviceName"),
            irdbImportSelected: document.getElementById("irdbImportSelected"),
            irdbSelectionSummary: document.getElementById("irdbSelectionSummary"),
            irdbCommandsContainer: document.getElementById("irdbCommandsContainer"),
            guidedStatusBadge: document.getElementById("guidedStatusBadge"),
            guidedDeviceType: document.getElementById("guidedDeviceType"),
            guidedBrand: document.getElementById("guidedBrand"),
            guidedBrandHint: document.getElementById("guidedBrandHint"),
            guidedTargetDevice: document.getElementById("guidedTargetDevice"),
            guidedNewDevice: document.getElementById("guidedNewDevice"),
            guidedStart: document.getElementById("guidedStart"),
            guidedStop: document.getElementById("guidedStop"),
            guidedLoadIndex: document.getElementById("guidedLoadIndex"),
            guidedStatus: document.getElementById("guidedStatus"),
            guidedFeedback: document.getElementById("guidedFeedback"),
            guidedDatasetLabel: document.getElementById("guidedDatasetLabel"),
            guidedCurrentCommand: document.getElementById("guidedCurrentCommand"),
            guidedFeedbackYes: document.getElementById("guidedFeedbackYes"),
            guidedFeedbackNo: document.getElementById("guidedFeedbackNo"),
            guidedFeedbackSkip: document.getElementById("guidedFeedbackSkip"),
            guidedHistory: document.getElementById("guidedHistory"),
            irManualForm: document.getElementById("irManualForm"),
            irManualName: document.getElementById("irManualName"),
            irManualProtocol: document.getElementById("irManualProtocol"),
            irManualBits: document.getElementById("irManualBits"),
            irManualValue: document.getElementById("irManualValue"),
            irManualRaw: document.getElementById("irManualRaw"),
            identificationBadge: document.getElementById("identificationBadge"),
            identifyFromScan: document.getElementById("identifyFromScan"),
            identifyFromProfile: document.getElementById("identifyFromProfile"),
            identificationStatus: document.getElementById("identificationStatus"),
            identificationResults: document.getElementById("identificationResults"),
            scanStatus: document.getElementById("scanStatus"),
            scanModeBadge: document.getElementById("scanModeBadge"),
            scanTargetDevice: document.getElementById("scanTargetDevice"),
            scanNewDeviceName: document.getElementById("scanNewDeviceName"),
            startScanMode: document.getElementById("startScanMode"),
            stopScanMode: document.getElementById("stopScanMode"),
            scanInstructions: document.getElementById("scanInstructions"),
            scannedCountBadge: document.getElementById("scannedCountBadge"),
            scannedCodesContainer: document.getElementById("scannedCodesContainer"),
            clearScannedCodes: document.getElementById("clearScannedCodes"),
            saveScannedCodes: document.getElementById("saveScannedCodes"),
            remoteDeviceSelect: document.getElementById("remoteDeviceSelect"),
            remoteType: document.getElementById("remoteType"),
            createRemoteBtn: document.getElementById("createRemoteBtn"),
            loadRemoteBtn: document.getElementById("loadRemoteBtn"),
            saveRemoteBtn: document.getElementById("saveRemoteBtn"),
            remoteBuilderContainer: document.getElementById("remoteBuilderContainer"),
            remoteTypeName: document.getElementById("remoteTypeName"),
            remotePreview: document.getElementById("remotePreview"),
            addCustomButton: document.getElementById("addCustomButton"),
            resetRemoteLayout: document.getElementById("resetRemoteLayout"),
            bindingPanel: document.getElementById("bindingPanel"),
            selectedButtonName: document.getElementById("selectedButtonName"),
            bindCommandSelect: document.getElementById("bindCommandSelect"),
            bindCommandBtn: document.getElementById("bindCommandBtn"),
            testRemoteCommandBtn: document.getElementById("testRemoteCommandBtn"),
            unbindCommandBtn: document.getElementById("unbindCommandBtn"),
            learnCommandBtn: document.getElementById("learnCommandBtn"),
            savedRemotesList: document.getElementById("savedRemotesList"),
          };

          const supportsFetch = typeof window.fetch === "function";
          const supportsEventSource = typeof window.EventSource === "function";

          const GUIDED_DEVICE_TYPES = {
            tv: {
              label: "TV / Monitor",
              keywords: ["tv", "television", "monitor", "display"],
              priorities: [
                { token: "POWERTOGGLE", score: 120 },
                { token: "POWERON", score: 115 },
                { token: "POWEROFF", score: 110 },
                { token: "POWER", score: 105 },
                { token: "INPUT", score: 95 },
                { token: "SOURCE", score: 94 },
                { token: "AV", score: 92 },
                { token: "VOLUMEUP", score: 90 },
                { token: "VOLUMEDOWN", score: 88 },
                { token: "CHANNELUP", score: 84 },
                { token: "CHANNELDOWN", score: 82 },
                { token: "MENU", score: 78 },
                { token: "OK", score: 76 },
                { token: "ENTER", score: 74 },
              ],
            },
            led: {
              label: "Striscia LED / Illuminazione",
              keywords: ["led", "light", "lighting", "illum", "strip"],
              priorities: [
                { token: "POWER", score: 110 },
                { token: "ON", score: 105 },
                { token: "OFF", score: 102 },
                { token: "WHITE", score: 95 },
                { token: "BRIGHT", score: 92 },
                { token: "COLOR", score: 88 },
                { token: "MODE", score: 84 },
                { token: "FLASH", score: 80 },
              ],
            },
            settop: {
              label: "Decoder / Set-top box",
              keywords: ["decoder", "set", "box", "sat", "cable", "dvb"],
              priorities: [
                { token: "POWER", score: 110 },
                { token: "MENU", score: 100 },
                { token: "GUIDE", score: 96 },
                { token: "OK", score: 94 },
                { token: "ENTER", score: 92 },
                { token: "CHANNELUP", score: 90 },
                { token: "CHANNELDOWN", score: 88 },
                { token: "INFO", score: 84 },
              ],
            },
            audio: {
              label: "Soundbar / Audio",
              keywords: ["amp", "audio", "avr", "sound", "receiver", "soundbar"],
              priorities: [
                { token: "POWER", score: 110 },
                { token: "VOLUMEUP", score: 100 },
                { token: "VOLUMEDOWN", score: 98 },
                { token: "MUTE", score: 96 },
                { token: "INPUT", score: 94 },
                { token: "SOURCE", score: 92 },
                { token: "BASS", score: 86 },
                { token: "TREBLE", score: 84 },
              ],
            },
            projector: {
              label: "Proiettore",
              keywords: ["projector", "beam", "beamer"],
              priorities: [
                { token: "POWER", score: 110 },
                { token: "POWEROFF", score: 108 },
                { token: "POWERON", score: 106 },
                { token: "SOURCE", score: 98 },
                { token: "INPUT", score: 96 },
                { token: "MENU", score: 92 },
                { token: "OK", score: 90 },
                { token: "KEYSTONE", score: 86 },
              ],
            },
            ac: {
              label: "Climatizzatore",
              keywords: ["air", "conditioner", "clima", "climatizzatore", "ac"],
              priorities: [
                { token: "POWER", score: 112 },
                { token: "MODE", score: 105 },
                { token: "TEMPUP", score: 100 },
                { token: "TEMPDOWN", score: 98 },
                { token: "FAN", score: 94 },
                { token: "SWING", score: 90 },
              ],
            },
          };
          const GUIDED_FALLBACK_PRIORITIES = [
            { token: "POWER", score: 80 },
            { token: "ON", score: 70 },
            { token: "OFF", score: 68 },
          ];

          // Configurazione invio intelligente
          const GUIDED_COMMAND_INTERVAL_MS = 400; // Ridotto da 900ms a 400ms per test pi√π rapidi
          const GUIDED_MAX_COMMANDS_PER_DATASET = 8; // Max comandi da testare per dataset
          const GUIDED_MIN_PRIORITY_THRESHOLD = 70; // Testa solo comandi con priorit√† >= 70
          const GUIDED_AUTO_SKIP_THRESHOLD = 8; // Skip automatico dopo 8 comandi senza risposta
          const GUIDED_AUTO_MODE = true; // Modalit√† ricorsiva automatica - continua fino a trovare il device

          if (dom.endpointBase) {
            dom.endpointBase.textContent = "/special_action";
          }

        function showToast(message, type = "info") {
          if (!dom.toast) return;
          dom.toast.textContent = message;
          dom.toast.className = `toast show ${type}`;
          setTimeout(() => {
            dom.toast.className = "toast";
          }, 3200);
        }

        function escapeHtml(value) {
          if (value === null || value === undefined) {
            return "";
          }
          return String(value)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        function deepClone(value) {
          return value ? JSON.parse(JSON.stringify(value)) : {};
        }

        function formatBytes(bytes) {
          if (!bytes || bytes <= 0) return "0 B";
          const units = ["B", "KB", "MB", "GB"];
          let idx = 0;
          let size = bytes;
          while (size >= 1024 && idx < units.length - 1) {
            size /= 1024;
            idx += 1;
          }
          return `${size.toFixed(idx === 0 ? 0 : 2)} ${units[idx]}`;
        }

        function setupTabs() {
          dom.tabButtons.forEach((button) => {
            button.addEventListener("click", () => {
              const target = button.getAttribute("data-tab-target");
              if (!target || target === state.activeTab) {
                return;
              }
              state.activeTab = target;
              dom.tabButtons.forEach((btn) => {
                btn.classList.toggle("active", btn === button);
              });
              dom.panels.forEach((panel) => {
                panel.classList.toggle("active", panel.id === target);
              });
              if (target === "tab-ir" && !state.ir.initialized) {
                state.ir.initialized = true;
                initializeIrModule();
              }
              if (target === "tab-irscan") {
                console.log("[IR SCAN] IR Scan tab activated, syncing device select");
                syncScanDeviceSelect();
              }
            });
          });
        }

        function assignActionKey(action, index) {
          if (!action) {
            return `action-${index}`;
          }
          if (action._key) {
            return action._key;
          }
          const base =
            action.id || action.actionId || action.endpoint || `action-${index}`;
          action._key = String(base);
          return action._key;
        }

        function getPayloadTemplate(action) {
          if (!action || !action.actionId) {
            return "";
          }
          if (action.example) {
            try {
              const parsed = JSON.parse(action.example);
              return JSON.stringify(parsed, null, 2);
            } catch (error) {
              return action.example;
            }
          }
          const payload = { actionId: action.actionId };
          if (action.requiresParams) {
            payload.params = {};
          }
          return JSON.stringify(payload, null, 2);
        }

        function buildActionCard(action, template) {
          const key = action._key || assignActionKey(action, 0);
          const method = (action.method || "POST").toUpperCase();
          const isAggregator = Boolean(action.actionId);
          const endpoint = action.endpoint || (isAggregator ? "/special_action" : "");
          const badgeClass = `method-${method.toLowerCase()}`;
          const description = action.description || "";
          const actionIdBadge = isAggregator
            ? `<span class="action-id-badge">actionId: <strong>${escapeHtml(
                action.actionId
              )}</strong></span>`
            : "";
          const editorBlock = isAggregator
            ? `<textarea class="action-editor" data-action-editor>${escapeHtml(
                template
              )}</textarea>`
            : "";
          const resetButton = isAggregator
            ? '<button class="secondary-btn" data-action-reset><i class="fas fa-undo"></i>Reset</button>'
            : "";
          const copyButton =
            '<button class="secondary-btn" data-action-copy><i class="fas fa-copy"></i>cURL</button>';

          return `
            <article class="card action-card" data-action-key="${escapeHtml(
              key
            )}" data-aggregator="${isAggregator}">
              <header class="card-header">
                <div>
                  <h3 class="card-title">${escapeHtml(action.label || key)}</h3>
                  <p class="card-subtitle">${escapeHtml(description)}</p>
                </div>
                <span class="endpoint-pill ${badgeClass}">${method}</span>
              </header>
              <div class="action-body">
                <div class="endpoint-row">
                  <code class="endpoint-path">${escapeHtml(endpoint)}</code>
                  ${actionIdBadge}
                </div>
                ${editorBlock}
                <div class="action-buttons">
                  <button class="primary-btn" data-action-run>
                    <i class="fas fa-play"></i>Esegui
                  </button>
                  ${resetButton}
                  ${copyButton}
                </div>
                <div class="action-status" data-action-status></div>
              </div>
            </article>
          `;
        }

        function renderActionCatalog(actions) {
          state.payloadTemplates = {};
          if (!Array.isArray(actions) || actions.length === 0) {
            if (dom.actionContainer) {
              dom.actionContainer.innerHTML =
                '<div class="empty-state">Nessuna azione disponibile.</div>';
            }
            if (dom.actionsCount) {
              dom.actionsCount.textContent = "0";
            }
            return;
          }

          const sorted = [...actions].sort((a, b) => {
            const left = (a.label || a.id || "").toLowerCase();
            const right = (b.label || b.id || "").toLowerCase();
            return left.localeCompare(right);
          });

          const markup = sorted
            .map((action, index) => {
              assignActionKey(action, index);
              const template = getPayloadTemplate(action);
              state.payloadTemplates[action._key] = template;
              return buildActionCard(action, template);
            })
            .join("");

          if (dom.actionContainer) {
            dom.actionContainer.innerHTML = markup;
          }
          if (dom.actionsCount) {
            dom.actionsCount.textContent = String(sorted.length);
          }
        }

        function getActionByKey(key) {
          if (!key) return undefined;
          return state.actions.find((action) => action._key === key);
        }

        function setActionStatus(card, message, type) {
          if (!card) return;
          const statusEl = card.querySelector("[data-action-status]");
          if (!statusEl) return;
          statusEl.textContent = message || "";
          statusEl.classList.remove("success", "error");
          if (type === "success" || type === "error") {
            statusEl.classList.add(type);
          }
        }

        async function handleRunAction(action, card) {
          if (!action || !card) return;
          const isAggregator = Boolean(action.actionId);
          const method = (action.method || "POST").toUpperCase();
          const endpoint = action.endpoint || (isAggregator ? "/special_action" : "");
          const headers = {};
          let body = null;

          if (isAggregator) {
            const editor = card.querySelector(".action-editor");
            let payloadText = editor ? editor.value.trim() : "";
            if (!payloadText) {
              payloadText =
                state.payloadTemplates[action._key] ||
                JSON.stringify({ actionId: action.actionId }, null, 2);
              if (editor) {
                editor.value = payloadText;
              }
            }
            let payloadObject;
            try {
              payloadObject = JSON.parse(payloadText);
            } catch (error) {
              setActionStatus(card, "JSON non valido.", "error");
              showToast("Payload JSON non valido.", "error");
              return;
            }
            if (!payloadObject.actionId) {
              payloadObject.actionId = action.actionId;
            }
            headers["Content-Type"] = "application/json";
            body = JSON.stringify(payloadObject);
          }

          setActionStatus(card, "Esecuzione in corso...");

          try {
            const response = await fetch(endpoint, {
              method,
              headers,
              body,
            });
            const raw = await response.text();
            if (!response.ok) {
              setActionStatus(card, raw || `Errore ${response.status}`, "error");
              showToast(
                `Errore ${response.status} durante ${action.label || action.id}`,
                "error"
              );
              return;
            }
            let message = raw;
            if (raw) {
              try {
                const parsed = JSON.parse(raw);
                message = parsed.message || parsed.status || raw;
              } catch (error) {
                message = raw;
              }
            }
            setActionStatus(card, message || "Azione eseguita.", "success");
            showToast(`${action.label || action.id} eseguita.`, "success");
          } catch (error) {
            console.error(error);
            setActionStatus(card, error.message || "Errore inaspettato.", "error");
            showToast("Errore durante l'esecuzione.", "error");
          }
        }

        function handleResetAction(action, card) {
          if (!action || !card) return;
          const editor = card.querySelector(".action-editor");
          if (!editor) return;
          const template = state.payloadTemplates[action._key];
          if (template !== undefined) {
            editor.value = template;
            setActionStatus(card, "Payload ripristinato.");
          }
        }

        function buildCurlCommand(action, payloadText) {
          const method = (action.method || "POST").toUpperCase();
          const endpoint = action.endpoint || (action.actionId ? "/special_action" : "");
          const url = `${window.location.origin}${endpoint}`;
          if (action.actionId) {
            const template =
              payloadText && payloadText.trim()
                ? payloadText.trim()
                : state.payloadTemplates[action._key] ||
                  JSON.stringify({ actionId: action.actionId }, null, 2);
            const escapedPayload = template.replace(/'/g, "'\\''");
            return `curl -X ${method} "${url}" -H "Content-Type: application/json" -d '${escapedPayload}'`;
          }
          return `curl -X ${method} "${url}"`;
        }

        async function copyToClipboard(value, successMessage) {
          if (!value) {
            showToast("Nessun contenuto da copiare.", "error");
            return;
          }
          try {
            await navigator.clipboard.writeText(value);
            showToast(successMessage || "Copiato negli appunti.", "success");
          } catch (error) {
            console.error("Clipboard error:", error);
            showToast("Impossibile copiare negli appunti.", "error");
          }
        }

        async function handleCopyCurl(action, card) {
          if (!action || !card) return;
          let payloadText = "";
          if (action.actionId) {
            const editor = card.querySelector(".action-editor");
            payloadText = editor ? editor.value : "";
          }
          const command = buildCurlCommand(action, payloadText);
          await copyToClipboard(command, "Comando cURL copiato.");
          setActionStatus(card, "Comando cURL copiato.");
        }

        function handleActionContainerClick(event) {
          const card = event.target.closest(".action-card");
          if (!card) return;
          const key = card.getAttribute("data-action-key");
          const action = getActionByKey(key);
          if (!action) return;

          if (event.target.closest("[data-action-run]")) {
            handleRunAction(action, card);
            return;
          }

          if (event.target.closest("[data-action-reset]")) {
            handleResetAction(action, card);
            return;
          }

          if (event.target.closest("[data-action-copy]")) {
            handleCopyCurl(action, card);
          }
        }

        async function loadActionCatalog(showFeedback = false) {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          if (dom.actionContainer) {
            dom.actionContainer.innerHTML =
              '<div class="loading-state">Caricamento azioni...</div>';
          }
          try {
            const response = await fetch("/special_actions.json", {
              cache: "no-cache",
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            const actions = Array.isArray(payload.actions)
              ? payload.actions
              : [];
            actions.forEach((action, index) => assignActionKey(action, index));
            state.actions = actions;
            renderActionCatalog(actions);
            if (showFeedback) {
              showToast("Elenco azioni aggiornato.", "success");
            }
          } catch (error) {
            console.error(error);
            if (dom.actionContainer) {
              dom.actionContainer.innerHTML =
                '<div class="empty-state error">Errore nel caricamento delle azioni.</div>';
            }
            if (dom.actionsCount) {
              dom.actionsCount.textContent = "0";
            }
            showToast("Errore nel caricamento delle azioni.", "error");
          }
        }

        function appendLog(message, variant = "info") {
          if (!dom.logStream) return;
          const entry = document.createElement("div");
          entry.className = `log-entry ${variant}`;
          entry.textContent = message;
          dom.logStream.appendChild(entry);
          while (dom.logStream.childNodes.length > 400) {
            dom.logStream.removeChild(dom.logStream.firstChild);
          }
          dom.logStream.scrollTop = dom.logStream.scrollHeight;
        }

        function processLogMessage(message) {
          try {
            if (message.includes("IR:") || message.includes("\"protocol\"")) {
              console.log("[IR PROCESSING] Potential IR message detected:", message);
              const jsonMatch = message.match(/\{.*\}/);
              if (jsonMatch) {
                console.log("[IR PROCESSING] JSON found:", jsonMatch[0]);
                const irData = JSON.parse(jsonMatch[0]);
                console.log("[IR PROCESSING] Parsed IR data:", irData);
                if (irData.protocol && irData.bits) {
                  console.log("[IR PROCESSING] Valid IR data, processing...");
                  processScannedIrCode(irData);
                  processScannedIrCodeForTab(irData);
                  return;
                } else {
                  console.log("[IR PROCESSING] Missing protocol or bits:", irData);
                }
              } else {
                console.log("[IR PROCESSING] No JSON found in message");
              }
            }
          } catch (error) {
            console.debug("[IR PROCESSING] Not an IR message or parsing error:", message, error);
          }
        }

        function setupLogs() {
          if (!supportsEventSource) {
            appendLog("EventSource non supportato dal browser.", "error");
            showToast("EventSource non supportato.", "error");
            return;
          }
          if (state.eventSource) {
            state.eventSource.close();
            state.eventSource = null;
          }
          if (dom.logStream) {
            dom.logStream.innerHTML = "";
          }
          try {
            const source = new EventSource("/log");
            state.eventSource = source;
            source.onopen = () => appendLog("Connessione log stabilita.", "success");
            source.onmessage = (event) => {
              appendLog(event.data);
              processLogMessage(event.data);
            };
            source.onerror = () => {
              appendLog("Connessione log interrotta.", "error");
              showToast("Connessione ai log interrotta.", "error");
              source.close();
              state.eventSource = null;
            };
          } catch (error) {
            console.error(error);
            appendLog("Impossibile inizializzare lo stream log.", "error");
            showToast("Errore nell'apertura dei log.", "error");
          }
        }

        function updateIrDirtyUI() {
          if (!dom.irDirtyStatus) return;
          if (state.ir.dirty) {
            dom.irDirtyStatus.textContent = "Modifiche non salvate";
            dom.irDirtyStatus.classList.remove("muted");
          } else {
            dom.irDirtyStatus.textContent = "Nessuna modifica";
            dom.irDirtyStatus.classList.add("muted");
          }
          if (dom.irSaveChanges) {
            dom.irSaveChanges.disabled = !state.ir.dirty;
          }
        }

        function getDeviceNames() {
          return Object.keys(state.ir.devices || {}).sort((a, b) =>
            a.localeCompare(b, "it", { sensitivity: "base" })
          );
        }

        function syncDeviceSelects() {
          const names = getDeviceNames();
          if (names.length === 0) {
            state.ir.selectedDevice = "";
          } else if (!names.includes(state.ir.selectedDevice)) {
            state.ir.selectedDevice = names[0];
          }

          if (dom.irDeviceSelect) {
            dom.irDeviceSelect.innerHTML = names.length
              ? names
                  .map(
                    (name) =>
                      `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`
                  )
                  .join("")
              : '<option value="">Nessun dispositivo</option>';
            dom.irDeviceSelect.value = state.ir.selectedDevice || "";
          }

          if (dom.irdbTargetDevice) {
            const options = [""].concat(names);
            dom.irdbTargetDevice.innerHTML = options
              .map((name) =>
                name
                  ? `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`
                  : '<option value="">Seleziona dispositivo</option>'
              )
              .join("");
            dom.irdbTargetDevice.value = state.ir.selectedDevice || "";
          }

          if (dom.guidedTargetDevice) {
            const options = [""].concat(names);
            dom.guidedTargetDevice.innerHTML = options
              .map((name) =>
                name
                  ? `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`
                  : '<option value="">Seleziona dispositivo</option>'
              )
              .join("");
            const preferred = state.guided.targetDevice || state.ir.selectedDevice || "";
            dom.guidedTargetDevice.value = preferred;
          }

          updateGuidedStartButtonState();
          syncScanDeviceSelect();
          syncRemoteDeviceSelect();
        }

        function renderLocalCommands() {
          if (!dom.irCommandsContainer) return;
          const deviceName = state.ir.selectedDevice;
          if (!deviceName) {
            dom.irCommandsContainer.innerHTML =
              '<div class="muted">Crea o seleziona un dispositivo per vedere i comandi.</div>';
            if (dom.irCommandCount) dom.irCommandCount.textContent = "0";
            return;
          }
          const commands = state.ir.devices[deviceName] || {};
          const entries = Object.entries(commands);
          if (dom.irCommandCount) dom.irCommandCount.textContent = entries.length;

          const approxSize = JSON.stringify({ devices: state.ir.devices || {} }).length;
          if (dom.irEstimatedSize) {
            dom.irEstimatedSize.textContent = formatBytes(approxSize);
          }

          if (entries.length === 0) {
            dom.irCommandsContainer.innerHTML =
              '<div class="muted">Nessun comando registrato per questo dispositivo.</div>';
            return;
          }

          const rows = entries
            .map(([name, data]) => {
              const proto = data && data.protocol ? data.protocol : "-";
              const bits = data && data.bits ? data.bits : "-";
              const value = data && data.value ? `0x${String(data.value).toLowerCase()}` : "-";
              const addressInfo = data && data.address !== undefined
                ? `<div class=\"muted\">address: ${escapeHtml(String(data.address))}</div>`
                : "";
              const commandInfo = data && data.command !== undefined
                ? `<div class=\"muted\">command: ${escapeHtml(String(data.command))}</div>`
                : "";
              const rawInfo = Array.isArray(data?.raw)
                ? `<div class=\"muted\">RAW len: ${data.raw.length}</div>`
                : "";
              const summary = proto === "RAW" && Array.isArray(data?.raw)
                ? `RAW (${data.raw.length})`
                : value;
              return `
                <tr>
                  <td><strong>${escapeHtml(name)}</strong></td>
                  <td>
                    <div>${escapeHtml(proto)}</div>
                    <div class="muted">bit: ${escapeHtml(String(bits))}</div>
                  </td>
                  <td>
                    <div>${escapeHtml(summary)}</div>
                    ${addressInfo}
                    ${commandInfo}
                    ${rawInfo}
                  </td>
                  <td>
                    <div class="actions-bar">
                      <button class="secondary-btn" data-ir-action="send" data-ir-device="${escapeHtml(
                        deviceName
                      )}" data-ir-command="${escapeHtml(name)}">
                        <i class="fas fa-paper-plane"></i>Invia
                      </button>
                      <button class="danger-btn" data-ir-action="delete" data-ir-device="${escapeHtml(
                        deviceName
                      )}" data-ir-command="${escapeHtml(name)}">
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </td>
                </tr>
              `;
            })
            .join("");

          dom.irCommandsContainer.innerHTML = `
            <div class="table-wrapper">
              <table class="simple-table">
                <thead>
                  <tr>
                    <th>Nome</th>
                    <th>Protocollo</th>
                    <th>Dati</th>
                    <th>Azioni</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
          `;
        }

        function markIrDirty() {
          if (!state.ir.dirty) {
            state.ir.dirty = true;
            updateIrDirtyUI();
          }
        }

        function sanitizeDeviceName(name) {
          if (!name) return "";
          return name
            .trim()
            .replace(/\s+/g, "_")
            .replace(/[^a-zA-Z0-9_\-]/g, "")
            .slice(0, 40);
        }

        function sanitizeCommandName(name, fallback) {
          const base = (name || "")
            .trim()
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "_")
            .replace(/^_+|_+$/g, "");
          if (base) return base.slice(0, 48);
          return fallback ? fallback.slice(0, 48) : "cmd";
        }

        async function loadLocalIrData(showFeedback = false) {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          try {
            const response = await fetch("/ir_data.json", { cache: "no-cache" });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            const devices = payload && typeof payload === "object" ? payload.devices || {} : {};
            state.ir.original = deepClone(devices);
            state.ir.devices = deepClone(devices);
            state.ir.dirty = false;
            syncDeviceSelects();
            renderLocalCommands();
            updateIrDirtyUI();
            if (showFeedback) showToast("IR locali aggiornati.", "success");
          } catch (error) {
            console.error("IR load error", error);
            showToast("Errore caricamento ir_data.json", "error");
          }
        }

        async function saveIrData() {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          try {
            if (!state.ir.dirty) {
              showToast("Nessuna modifica da salvare.", "info");
              return;
            }

            // Pulisci i dati prima del salvataggio: rimuovi campi undefined/null
            const cleanedDevices = {};
            Object.keys(state.ir.devices).forEach(deviceName => {
              const commands = state.ir.devices[deviceName];
              const cleanedCommands = {};

              Object.keys(commands).forEach(cmdName => {
                const cmd = commands[cmdName];
                const cleanedCmd = {};

                // Copia solo i campi validi (non undefined/null)
                Object.keys(cmd).forEach(key => {
                  const value = cmd[key];

                  // Skip undefined, null, NaN, Infinity
                  if (value === undefined || value === null) return;
                  if (typeof value === 'number' && (!isFinite(value))) return;

                  // Per oggetti, verifica che non siano vuoti
                  if (typeof value === 'object' && value !== null) {
                    if (Array.isArray(value) && value.length === 0) return;
                    if (!Array.isArray(value) && Object.keys(value).length === 0 && key !== 'source') return;
                  }

                  cleanedCmd[key] = value;
                });

                // Solo aggiungi comandi che hanno almeno protocol e bits
                if (cleanedCmd.protocol && cleanedCmd.bits) {
                  cleanedCommands[cmdName] = cleanedCmd;
                }
              });

              if (Object.keys(cleanedCommands).length > 0) {
                cleanedDevices[deviceName] = cleanedCommands;
              }
            });

            const body = JSON.stringify({ devices: cleanedDevices }, null, 2);

            // DEBUG: log del JSON che stiamo per inviare
            console.log("[IR SAVE] JSON to send:", body.substring(0, 500) + "...");

            // Valida che il JSON sia parsabile
            try {
              JSON.parse(body);
            } catch (parseError) {
              throw new Error("Generated invalid JSON: " + parseError.message);
            }

            const response = await fetch("/ir_data.json", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body,
            });
            if (!response.ok) {
              const raw = await response.text();
              throw new Error(raw || `HTTP ${response.status}`);
            }
            showToast("IR data salvati con successo.", "success");
            state.ir.original = deepClone(state.ir.devices);
            state.ir.dirty = false;
            updateIrDirtyUI();
          } catch (error) {
            console.error("IR save error", error);
            showToast(`Errore salvataggio: ${error.message || error}`, "error");
          }
        }

        async function sendIrCommand(device, command) {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          try {
            const payload = {
              actionId: "send_ir_command",
              params: { device, command },
            };
            const response = await fetch("/special_action", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const raw = await response.text();
            if (!response.ok) {
              throw new Error(raw || `HTTP ${response.status}`);
            }
          } catch (error) {
            console.error("IR send error", error);
            showToast(error.message || "Errore invio IR", "error");
          }
        }

        function buildCommandPayloadFromConversion(conversion) {
          const commandPayload = {
            protocol: conversion.protocol,
            bits: conversion.bits,
            value: conversion.value,
          };
          ["address", "command", "device", "subdevice"].forEach((key) => {
            if (conversion[key] !== undefined && conversion[key] !== null) {
              commandPayload[key] = conversion[key];
            }
          });
          return commandPayload;
        }

        async function dispatchIrPayload(commandPayload, label) {
          if (!supportsFetch) {
            throw new Error("Fetch API non supportata dal browser.");
          }
          const payload = {
            actionId: "send_ir_payload",
            params: {
              label: label || "ir_payload",
              command: commandPayload,
            },
          };
          const response = await fetch("/special_action", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const raw = await response.text();
          if (!response.ok) {
            throw new Error(raw || `HTTP ${response.status}`);
          }
        }

        async function sendIrdbCommand(row) {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          if (!row || !row.conversion || !row.conversion.ok || !row.conversion.data) {
            showToast("Comando irdb non supportato o incompleto.", "error");
            return;
          }
          const conversion = row.conversion.data;
          const commandPayload = buildCommandPayloadFromConversion(conversion);
          const entryPath = state.irdb.selectedEntry ? state.irdb.selectedEntry.path : "";
          const labelParts = [];
          if (row.name) labelParts.push(row.name);
          if (entryPath) labelParts.push(entryPath);
          const label = labelParts.join(" ¬∑ ") || row.name || "irdb_cmd";
          try {
            await dispatchIrPayload(commandPayload, label);
          } catch (error) {
            console.error("IRDB send error", error);
            showToast(error.message || "Errore invio IR da irdb", "error");
          }
        }

        function handleIrCommandClick(event) {
          const button = event.target.closest("[data-ir-action]");
          if (!button) return;
          const action = button.getAttribute("data-ir-action");
          const device = button.getAttribute("data-ir-device") || "";
          const command = button.getAttribute("data-ir-command") || "";
          if (!device || !command) return;

          if (action === "send") {
            sendIrCommand(device, command);
          }

          if (action === "delete") {
            const commands = state.ir.devices[device] || {};
            if (!commands[command]) return;
            if (!window.confirm(`Eliminare il comando ${command}?`)) return;
            delete commands[command];
            state.ir.devices[device] = commands;
            markIrDirty();
            renderLocalCommands();
            showToast(`Comando ${command} rimosso.`, "success");
          }
        }

        function ensureDevice(name) {
          if (!state.ir.devices[name]) {
            state.ir.devices[name] = {};
          }
          return state.ir.devices[name];
        }

        function parseRawString(rawText) {
          return rawText
            .split(/[,\s]+/)
            .map((chunk) => chunk.trim())
            .filter((chunk) => chunk.length > 0)
            .map((chunk) => parseInt(chunk, 10))
            .filter((value) => Number.isFinite(value) && value > 0);
        }

        function handleManualSubmit(event) {
          event.preventDefault();
          if (!state.ir.selectedDevice) {
            showToast("Seleziona un dispositivo prima di aggiungere un comando.", "error");
            return;
          }
          const nameInput = dom.irManualName ? dom.irManualName.value : "";
          const protocol = dom.irManualProtocol ? dom.irManualProtocol.value.trim() : "";
          const bitsValue = dom.irManualBits ? Number(dom.irManualBits.value) : 0;
          const valueHex = dom.irManualValue ? dom.irManualValue.value.trim() : "";
          const rawText = dom.irManualRaw ? dom.irManualRaw.value.trim() : "";

          const commandName = sanitizeCommandName(nameInput, "cmd");
          if (!commandName) {
            showToast("Nome comando non valido.", "error");
            return;
          }
          if (!protocol) {
            showToast("Seleziona un protocollo.", "error");
            return;
          }
          if (!Number.isFinite(bitsValue) || bitsValue <= 0) {
            showToast("Numero di bit non valido.", "error");
            return;
          }

          const deviceCommands = ensureDevice(state.ir.selectedDevice);
          if (deviceCommands[commandName]) {
            showToast("Nome comando gi√† utilizzato.", "error");
            return;
          }

          const payload = { protocol, bits: bitsValue };
          if (protocol.toUpperCase() === "RAW") {
            const rawArray = parseRawString(rawText);
            if (!rawArray.length) {
              showToast("Inserisci almeno un valore RAW.", "error");
              return;
            }
            payload.raw = rawArray;
          } else {
            if (!valueHex) {
              showToast("Inserisci un valore HEX.", "error");
              return;
            }
            const normalized = valueHex.replace(/^0x/i, "").toLowerCase();
            if (!/^[0-9a-f]+$/.test(normalized)) {
              showToast("Valore HEX non valido.", "error");
              return;
            }
            payload.value = normalized;
          }

          payload.source = { type: "manual" };

          deviceCommands[commandName] = payload;
          markIrDirty();
          renderLocalCommands();
          if (dom.irManualForm) dom.irManualForm.reset();
          showToast(`Comando ${commandName} aggiunto.`, "success");
        }

        function reverseBits(value, width) {
          let result = 0;
          for (let i = 0; i < width; i += 1) {
            if (value & (1 << i)) {
              result |= 1 << (width - 1 - i);
            }
          }
          return result >>> 0;
        }

        function encodeNec(address, command) {
          let cmd = command & 0xff;
          cmd = reverseBits(cmd, 8);
          cmd = (cmd << 8) + (cmd ^ 0xff);
          if (address > 0xff) {
            const addr = reverseBits(address & 0xffff, 16);
            return ((addr << 16) | cmd) >>> 0;
          }
          const addr = reverseBits(address & 0xff, 8);
          return (((addr << 24) | ((addr ^ 0xff) << 16) | cmd) >>> 0);
        }

        function encodeSony(bits, command, address, extended) {
          let result = 0;
          switch (bits) {
            case 12:
              result = address & 0x1f;
              break;
            case 15:
              result = address & 0xff;
              break;
            case 20:
              result = address & 0x1f;
              result |= (extended & 0xff) << 5;
              break;
            default:
              return null;
          }
          result = (result << 7) | (command & 0x7f);
          return reverseBits(result, bits) >>> 0;
        }

        function convertIrdbRow(row) {
          const proto = (row.protocol || "").trim().toUpperCase();
          const device = Number(row.device);
          const subdeviceRaw = row.subdevice === "" || row.subdevice === undefined ? NaN : Number(row.subdevice);
          const functionCode = Number(row.functionCode);
          if (!Number.isInteger(device) || device < 0) {
            return { ok: false, reason: "Device non valido" };
          }
          if (!Number.isInteger(functionCode) || functionCode < 0) {
            return { ok: false, reason: "Function non valida" };
          }

          const necVariants = new Set(["NEC", "NEC1", "NEC2", "NECX1", "NECX2", "NEC1-F16", "NEC1-F8", "NEC2-F16"]);
          const sonyMap = {
            SONY: 12,
            SONY12: 12,
            SONY15: 15,
            SONY20: 20,
          };

          if (necVariants.has(proto)) {
            let sub = Number.isInteger(subdeviceRaw) ? subdeviceRaw : -1;
            if (sub < 0) {
              sub = (~device) & 0xff;
            }
            const address = ((sub & 0xff) << 8) | (device & 0xff);
            const value = encodeNec(address, functionCode);
            if (value === undefined || value === null) {
              return { ok: false, reason: "Encoding NEC fallito" };
            }
            return {
              ok: true,
              data: {
                protocol: "NEC",
                bits: 32,
                value: value.toString(16).padStart(8, "0"),
                address,
                command: functionCode,
                device,
                subdevice: subdeviceRaw,
              },
            };
          }

          if (proto in sonyMap) {
            const bits = sonyMap[proto];
            const address = device;
            const extended = Number.isInteger(subdeviceRaw) && subdeviceRaw >= 0 ? subdeviceRaw : 0;
            const encoded = encodeSony(bits, functionCode, address, extended);
            if (encoded === null) {
              return { ok: false, reason: "Encoding SONY non supportato" };
            }
            return {
              ok: true,
              data: {
                protocol: "SONY",
                bits,
                value: encoded.toString(16).padStart(Math.ceil(bits / 4), "0"),
                command: functionCode,
                address,
                device,
                subdevice: subdeviceRaw,
              },
            };
          }

          if (proto === "SAMSUNG" || proto === "SAMSUNG32") {
            const customer = device & 0xff;
            const command = functionCode & 0xff;
            const revcustomer = reverseBits(customer, 8) & 0xff;
            const revcommand = reverseBits(command, 8) & 0xff;
            const value =
              ((revcustomer << 24) |
                (revcustomer << 16) |
                (revcommand << 8) |
                (revcommand ^ 0xff)) >>>
              0;
            return {
              ok: true,
              data: {
                protocol: "SAMSUNG",
                bits: 32,
                value: value.toString(16).padStart(8, "0"),
                command: functionCode,
                address: customer,
                device,
                subdevice: subdeviceRaw,
              },
            };
          }

          return { ok: false, reason: `Protocollo ${row.protocol} non supportato` };
        }

        function parseCsvLine(line) {
          const values = [];
          let current = "";
          let inQuotes = false;
          for (let i = 0; i < line.length; i += 1) {
            const char = line[i];
            if (char === '"') {
              if (inQuotes && line[i + 1] === '"') {
                current += '"';
                i += 1;
              } else {
                inQuotes = !inQuotes;
              }
              continue;
            }
            if (char === "," && !inQuotes) {
              values.push(current);
              current = "";
            } else {
              current += char;
            }
          }
          values.push(current);
          return values.map((item) => item.trim());
        }

        function parseIrdbCsv(text) {
          const lines = text.split(/\r?\n/).filter((line) => line.trim().length > 0);
          if (lines.length <= 1) {
            return [];
          }
          const header = parseCsvLine(lines[0]);
          if (header.length < 5) {
            return [];
          }
          const rows = [];
          for (let i = 1; i < lines.length; i += 1) {
            const parts = parseCsvLine(lines[i]);
            if (parts.length < 5) continue;
            const row = {
              index: rows.length,
              name: parts[0],
              protocol: parts[1],
              device: parts[2],
              subdevice: parts[3],
              functionCode: parts[4],
            };
            const conversion = convertIrdbRow({
              protocol: row.protocol,
              device: row.device,
              subdevice: row.subdevice,
              functionCode: row.functionCode,
            });
            row.conversion = conversion;
            rows.push(row);
          }
          return rows;
        }

        function renderIrdbResults() {
          if (!dom.irdbResults) return;
          if (state.irdb.filtered.length === 0) {
            dom.irdbResults.innerHTML = '<div class="muted">Nessun risultato. Prova con un altro filtro.</div>';
            return;
          }
          const markup = state.irdb.filtered
            .slice(0, MAX_IRDB_RESULTS)
            .map((entry) => {
              const active = state.irdb.selectedEntry && state.irdb.selectedEntry.path === entry.path;
              return `
                <div class="list-item${active ? " active" : ""}" data-irdb-path="${escapeHtml(
                  entry.path
                )}">
                  <strong>${escapeHtml(entry.manufacturer)}</strong>
                  <span class="muted">${escapeHtml(entry.category || "")}</span>
                  <span class="muted">${escapeHtml(entry.file)}</span>
                </div>
              `;
            })
            .join("");
          dom.irdbResults.innerHTML = markup;
        }

        function updateIrdbIndexStatus(message, type = "info") {
          if (!dom.irdbIndexStatus) return;
          dom.irdbIndexStatus.textContent = message;
          dom.irdbIndexStatus.className = type === "error" ? "badge error" : "muted";
        }

        function filterIrdbResults(query) {
          if (!state.irdb.index.length) return;
          const term = query.trim().toLowerCase();
          if (!term) {
            state.irdb.filtered = state.irdb.index.slice(0, MAX_IRDB_RESULTS);
          } else {
            state.irdb.filtered = state.irdb.index.filter((entry) => {
              return [
                entry.manufacturer,
                entry.category,
                entry.file,
                entry.path,
              ]
                .filter(Boolean)
                .some((value) => value.toLowerCase().includes(term));
            });
          }
          renderIrdbResults();
        }

        async function loadIrdbIndex(showFeedback = false) {
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          if (state.irdb.index.length) {
            // Se l'indice √® gi√† caricato, mostra i risultati e fornisci feedback
            state.irdb.filtered = state.irdb.index.slice(0, MAX_IRDB_RESULTS);
            updateIrdbIndexStatus(
              `Indice caricato: ${state.irdb.index.length} dataset disponibili.`
            );
            renderIrdbResults();
            updateGuidedBrandOptions();
            if (showFeedback) {
              showToast("Indice gi√† caricato.", "info");
            }
            return;
          }
          if (state.irdb.loadingIndex) {
            if (showFeedback) {
              showToast("Caricamento gi√† in corso...", "info");
            }
            return;
          }

          state.irdb.loadingIndex = true;
          updateIrdbIndexStatus("Scaricamento indice irdb in corso...");
          if (showFeedback) {
            showToast("Scaricamento indice irdb...", "info");
          }
          try {
            const response = await fetch(IRDB_INDEX_URL, { cache: "no-cache" });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const text = await response.text();
            const lines = text.split(/\r?\n/).filter((line) => line.startsWith("codes/"));
            state.irdb.index = lines
              .map((line) => {
                const relative = line.replace(/^codes\//, "");
                const parts = relative.split("/");
                if (parts.length < 2) return null;
                return {
                  path: line,
                  manufacturer: parts[0] || "",
                  category: parts[1] || "",
                  file: parts.slice(2).join("/") || parts[1] || "",
                };
              })
              .filter(Boolean);
            state.irdb.filtered = state.irdb.index.slice(0, MAX_IRDB_RESULTS);
            updateIrdbIndexStatus(
              `Indice caricato: ${state.irdb.index.length} dataset disponibili.`
            );
            renderIrdbResults();
            state.guided.datasetCache = {};
            state.guided.testedCommands = new Set();
            updateGuidedBrandOptions();
            updateGuidedStartButtonState();
            if (showFeedback) {
              showToast("Indice irdb caricato con successo.", "success");
            }
          } catch (error) {
            console.error("IRDB index error", error);
            state.irdb.index = [];
            state.irdb.filtered = [];
            updateIrdbIndexStatus("Errore durante il download dell'indice.", "error");
            showToast("Impossibile scaricare l'indice irdb.", "error");
            renderIrdbResults();
            updateGuidedBrandOptions();
            updateGuidedStartButtonState();
          } finally {
            state.irdb.loadingIndex = false;
          }
        }

        function updateIrdbDatasetBadge(text, type = "info") {
          if (!dom.irdbDatasetBadge) return;
          dom.irdbDatasetBadge.textContent = text;
          dom.irdbDatasetBadge.className = `badge ${type}`;
        }

        function updateIrdbSelectionSummary() {
          if (dom.irdbSelectionSummary) {
            dom.irdbSelectionSummary.textContent = `${state.irdb.selection.size} comandi selezionati.`;
          }
        }

        function renderIrdbCommands() {
          if (!dom.irdbCommandsContainer) return;
          if (!state.irdb.csv.length) {
            dom.irdbCommandsContainer.innerHTML =
              '<div class="muted">Nessun comando da visualizzare.</div>';
            updateIrdbSelectionSummary();
            return;
          }
          const rows = state.irdb.csv
            .map((row) => {
              const supported = row.conversion && row.conversion.ok;
              const status = supported
                ? '<span class="badge success">Supportato</span>'
                : `<span class="badge error">${escapeHtml(row.conversion?.reason || "Non supportato")}</span>`;
              const checked = state.irdb.selection.has(row.index) && supported ? "checked" : "";
              const disabled = supported ? "" : "disabled";
              const actionCell = supported
                ? `<button class="ghost-btn" data-irdb-action="send" data-irdb-index="${row.index}">
                    <i class="fas fa-paper-plane"></i>Invia
                   </button>`
                : '<span class="muted">‚Äî</span>';
              return `
                <tr data-irdb-index="${row.index}">
                  <td>
                    <input type="checkbox" data-irdb-index="${row.index}" ${checked} ${disabled} />
                  </td>
                  <td>
                    <strong>${escapeHtml(row.name)}</strong>
                    <div class="muted">fun=${escapeHtml(row.functionCode)}</div>
                  </td>
                  <td>
                    <div>${escapeHtml(row.protocol)}</div>
                    <div class="muted">device=${escapeHtml(row.device)} sub=${escapeHtml(row.subdevice)}</div>
                  </td>
                  <td>${status}</td>
                  <td>${actionCell}</td>
                </tr>
              `;
            })
            .join("");
          dom.irdbCommandsContainer.innerHTML = `
            <div class="table-wrapper">
              <table class="simple-table">
                <thead>
                  <tr>
                    <th>Sel</th>
                    <th>Comando</th>
                    <th>Protocollo</th>
                    <th>Stato</th>
                    <th>Test</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          `;
          updateIrdbSelectionSummary();
        }

        async function loadIrdbDataset(entry) {
          if (!entry) return;
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          updateIrdbDatasetBadge(`Caricamento ${entry.manufacturer}/${entry.file}...`, "info");
          state.irdb.csv = [];
          state.irdb.selection.clear();
          renderIrdbCommands();
          try {
            const response = await fetch(`${IRDB_CODES_BASE_URL}${entry.path}`, {
              cache: "no-cache",
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const text = await response.text();
            state.irdb.csv = parseIrdbCsv(text);
            if (!state.irdb.csv.length) {
              updateIrdbDatasetBadge("Dataset vuoto o non compatibile.", "error");
              dom.irdbCommandsContainer.innerHTML =
                '<div class="muted">Dataset vuoto o formattazione non supportata.</div>';
              return;
            }
            updateIrdbDatasetBadge(
              `${entry.manufacturer} ¬∑ ${entry.file} (${state.irdb.csv.length} comandi)`
            );
            renderIrdbCommands();
          } catch (error) {
            console.error("IRDB dataset error", error);
            updateIrdbDatasetBadge("Errore nel caricamento del dataset.", "error");
            dom.irdbCommandsContainer.innerHTML =
              '<div class="muted">Impossibile scaricare il dataset selezionato.</div>';
            showToast("Errore durante il download del dataset irdb.", "error");
          }
        }

        function handleIrdbResultClick(event) {
          const item = event.target.closest("[data-irdb-path]");
          if (!item) return;
          const path = item.getAttribute("data-irdb-path");
          const entry = state.irdb.index.find((it) => it.path === path);
          if (!entry) return;
          state.irdb.selectedEntry = entry;
          renderIrdbResults();
          loadIrdbDataset(entry);
        }

        function handleIrdbSelectionChange(event) {
          const checkbox = event.target.closest("input[type=checkbox][data-irdb-index]");
          if (!checkbox) return;
          const index = Number(checkbox.getAttribute("data-irdb-index"));
          if (!Number.isInteger(index)) return;
          if (checkbox.checked) {
            state.irdb.selection.add(index);
          } else {
            state.irdb.selection.delete(index);
          }
          updateIrdbSelectionSummary();
        }

        function handleIrdbCommandActions(event) {
          const button = event.target.closest("[data-irdb-action]");
          if (!button) return;
          const action = button.getAttribute("data-irdb-action");
          if (action !== "send") return;
          const index = Number(button.getAttribute("data-irdb-index"));
          if (!Number.isInteger(index)) return;
          const row = state.irdb.csv.find((item) => item.index === index);
          if (!row) {
            showToast("Comando irdb non trovato.", "error");
            return;
          }
          if (!row.conversion || !row.conversion.ok) {
            showToast("Comando irdb non supportato.", "error");
            return;
          }
          sendIrdbCommand(row);
        }

        function chooseTargetDevice() {
          const newDeviceRaw = dom.irdbNewDevice ? dom.irdbNewDevice.value : "";
          const sanitizedNew = sanitizeDeviceName(newDeviceRaw);
          if (sanitizedNew) {
            return sanitizedNew;
          }
          const selected = dom.irdbTargetDevice ? dom.irdbTargetDevice.value : "";
          return sanitizeDeviceName(selected);
        }

        function generateCommandName(baseName, fallback, existing) {
          const base = sanitizeCommandName(baseName, fallback);
          if (!existing[base]) {
            return base;
          }
          let idx = 2;
          while (existing[`${base}_${idx}`]) {
            idx += 1;
          }
          return `${base}_${idx}`;
        }

        function importSelectedIrdbCommands() {
          if (!state.ir.selectedDevice && !dom.irdbNewDevice?.value) {
            showToast("Seleziona o crea un dispositivo per importare i comandi.", "error");
            return;
          }
          if (!state.irdb.selection.size) {
            showToast("Seleziona almeno un comando da importare.", "error");
            return;
          }

          const targetDevice = chooseTargetDevice();
          if (!targetDevice) {
            showToast("Nome dispositivo non valido.", "error");
            return;
          }

          const commands = ensureDevice(targetDevice);
          let imported = 0;
          const entryPath = state.irdb.selectedEntry ? state.irdb.selectedEntry.path : "";
          state.irdb.selection.forEach((index) => {
            const row = state.irdb.csv.find((item) => item.index === index);
            if (!row || !row.conversion || !row.conversion.ok) {
              return;
            }
            const conversion = row.conversion.data;
            const commandName = generateCommandName(row.name, `cmd_${row.functionCode}`, commands);
            commands[commandName] = {
              protocol: conversion.protocol,
              value: conversion.value,
              bits: conversion.bits,
              address: conversion.address,
              command: conversion.command,
              device: conversion.device,
              subdevice: conversion.subdevice,
              source: {
                type: "irdb",
                path: entryPath,
                label: row.name,
              },
            };
            imported += 1;
          });

          if (imported === 0) {
            showToast("Nessun comando importato (forse non supportati).", "info");
            return;
          }

          state.ir.devices[targetDevice] = commands;
          state.ir.selectedDevice = targetDevice;
          markIrDirty();
          syncDeviceSelects();
          renderLocalCommands();
          showToast(`${imported} comandi importati in ${targetDevice}.`, "success");
        }

        // ========== GUIDED REMOTE BUILDER ==========

        function getGuidedLabel(typeId) {
          return GUIDED_DEVICE_TYPES[typeId]?.label || typeId.toUpperCase();
        }

        function normalizeGuidedName(value) {
          return (value || "").toUpperCase().replace(/[^A-Z0-9]/g, "");
        }

        function getGuidedPriorityScore(typeId, commandName) {
          const normalized = normalizeGuidedName(commandName);
          if (!normalized) return 1;
          const config = GUIDED_DEVICE_TYPES[typeId];
          if (config && Array.isArray(config.priorities)) {
            const match = config.priorities.find((item) => normalized.includes(item.token));
            if (match) {
              return match.score;
            }
          }
          const fallback = GUIDED_FALLBACK_PRIORITIES.find((item) => normalized.includes(item.token));
          return fallback ? fallback.score : 1;
        }

        function matchesGuidedCategory(entry, typeId) {
          if (!entry) return false;
          const config = GUIDED_DEVICE_TYPES[typeId];
          if (!config || !config.keywords || !config.keywords.length) return true;
          const haystack = [entry.category, entry.file, entry.path]
            .filter(Boolean)
            .join(" ")
            .toLowerCase();
          return config.keywords.some((keyword) => haystack.includes(keyword.toLowerCase()));
        }

        function describeGuidedEntry(entry) {
          if (!entry) return "Dataset sconosciuto";
          const manufacturer = entry.manufacturer || "Sconosciuto";
          const file = entry.file || entry.path || "";
          return `${manufacturer} ¬∑ ${file}`;
        }

        function collectGuidedBrands(typeId) {
          if (!state.irdb.index.length) return [];
          const brands = new Set();
          state.irdb.index.forEach((entry) => {
            if (!matchesGuidedCategory(entry, typeId)) return;
            if (entry.manufacturer) {
              brands.add(entry.manufacturer.trim());
            }
          });
          return Array.from(brands).sort((a, b) => a.localeCompare(b, "it", { sensitivity: "base" }));
        }

        function updateGuidedBrandOptions() {
          if (!dom.guidedBrand) return;
          const typeId = dom.guidedDeviceType ? dom.guidedDeviceType.value : state.guided.deviceType;
          const brands = collectGuidedBrands(typeId);
          if (!brands.length) {
            dom.guidedBrand.innerHTML = '<option value="">Carica l\'indice irdb per iniziare</option>';
            dom.guidedBrand.disabled = !state.irdb.index.length;
            state.guided.brand = "";
            if (dom.guidedBrandHint) {
              dom.guidedBrandHint.textContent = state.irdb.index.length
                ? "Nessuna marca trovata per questa categoria. Prova a cambiare categoria."
                : "Scarica l'indice irdb per popolare questo elenco.";
            }
          } else {
            const options = ['<option value="">Tutte le marche compatibili</option>']
              .concat(
                brands.map(
                  (brand) => `<option value="${escapeHtml(brand)}">${escapeHtml(brand)}</option>`
                )
              )
              .join("");
            dom.guidedBrand.innerHTML = options;
            dom.guidedBrand.disabled = false;
            if (state.guided.brand && brands.includes(state.guided.brand)) {
              dom.guidedBrand.value = state.guided.brand;
            } else {
              dom.guidedBrand.value = "";
              state.guided.brand = "";
            }
            if (dom.guidedBrandHint) {
              dom.guidedBrandHint.textContent =
                'Seleziona una marca o lascia "Tutte" per provare pi√π dataset.';
            }
          }
          updateGuidedStartButtonState();
        }

        function updateGuidedBadge(text, type = "info") {
          if (!dom.guidedStatusBadge) return;
          dom.guidedStatusBadge.textContent = text;
          dom.guidedStatusBadge.className = `badge ${type}`;
        }

        function updateGuidedStatus(message) {
          if (!dom.guidedStatus) return;
          const mapped = state.guided.mappedCount;
          const suffix = mapped > 0 ? ` ¬∑ ${mapped} comandi salvati` : "";
          dom.guidedStatus.textContent = `${message}${suffix}`;
        }

        function setGuidedFeedbackVisible(visible) {
          if (!dom.guidedFeedback) return;
          dom.guidedFeedback.classList.toggle("hidden", !visible);
        }

        function renderGuidedHistory() {
          if (!dom.guidedHistory) return;
          if (!state.guided.history.length) {
            dom.guidedHistory.innerHTML = '<div class="muted">Nessun test avviato.</div>';
            return;
          }
          const markup = state.guided.history
            .map((entry) => {
              const note = entry.note ? `<div class="muted">${escapeHtml(entry.note)}</div>` : "";
              return `
                <div class="guided-history-entry ${entry.status}">
                  <strong>${escapeHtml(entry.command)}</strong>
                  <div class="muted">${escapeHtml(entry.dataset)}</div>
                  ${note}
                </div>
              `;
            })
            .join("");
          dom.guidedHistory.innerHTML = markup;
        }

        function pushGuidedHistoryEntry(command, dataset) {
          const entry = {
            id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
            command,
            dataset,
            status: "pending",
            note: "",
          };
          state.guided.history.unshift(entry);
          if (state.guided.history.length > 30) {
            state.guided.history.pop();
          }
          renderGuidedHistory();
          return entry.id;
        }

        function updateGuidedHistoryEntry(id, status, note) {
          if (!id) return;
          const entry = state.guided.history.find((item) => item.id === id);
          if (!entry) return;
          if (status) {
            entry.status = status;
          }
          if (note !== undefined) {
            entry.note = note;
          }
          renderGuidedHistory();
        }

        async function importGuidedDataset(entry) {
          if (!entry) return 0;
          if (!state.guided.datasetCache[entry.path]) {
            state.guided.datasetCache[entry.path] = await loadIrdbDatasetQuiet(entry);
          }
          const dataset = state.guided.datasetCache[entry.path] || [];
          const target = state.guided.targetDevice || resolveGuidedTargetDevice() || state.ir.selectedDevice;
          if (!target) {
            return 0;
          }
          const commands = ensureDevice(target);
          let imported = 0;
          dataset.forEach((row) => {
            if (!row || !row.conversion || !row.conversion.ok || !row.conversion.data) {
              return;
            }
            const conversion = row.conversion.data;
            const name = generateCommandName(row.name, `cmd_${row.functionCode}`, commands);

            // Costruisci comando con solo i campi necessari
            const commandData = {
              protocol: conversion.protocol,
              bits: conversion.bits,
            };

            // Aggiungi value solo se presente (non RAW)
            // IMPORTANTE: value DEVE essere una stringa hex per il backend
            if (conversion.value !== undefined && conversion.value !== null) {
              const val = conversion.value;
              // Se √® gi√† una stringa, usala cos√¨ com'√®
              if (typeof val === 'string') {
                commandData.value = val.toLowerCase();
              }
              // Se √® un numero, convertilo in hex string
              else if (typeof val === 'number') {
                commandData.value = val.toString(16).toLowerCase();
              }
              // Altrimenti prova a convertirlo
              else {
                commandData.value = String(val).toLowerCase();
              }
            }

            // Aggiungi RAW se presente
            if (conversion.raw && Array.isArray(conversion.raw)) {
              commandData.raw = conversion.raw;
            }

            // Aggiungi campi opzionali solo se presenti
            ["address", "command", "device", "subdevice"].forEach((key) => {
              if (conversion[key] !== undefined && conversion[key] !== null) {
                commandData[key] = conversion[key];
              }
            });

            // Aggiungi metadata source
            commandData.source = {
              type: "guided",
              path: entry.path,
              label: row.name,
            };

            commands[name] = commandData;
            imported += 1;
          });
          if (imported > 0) {
            state.ir.devices[target] = commands;
            state.ir.selectedDevice = target;
            state.guided.targetDevice = target;
            state.guided.mappedCount = imported;
            markIrDirty();
            renderLocalCommands();
            syncDeviceSelects();
          }
          return imported;
        }

        function resolveGuidedTargetDevice() {
          const newName = dom.guidedNewDevice ? sanitizeDeviceName(dom.guidedNewDevice.value) : "";
          if (newName) {
            return newName;
          }
          const selected = dom.guidedTargetDevice
            ? dom.guidedTargetDevice.value
            : state.ir.selectedDevice;
          return sanitizeDeviceName(selected);
        }

        function updateGuidedStartButtonState() {
          if (!dom.guidedStart) return;
          const hasIndex = state.irdb.index.length > 0;
          const target = resolveGuidedTargetDevice();
          const disabled = !hasIndex || !target || state.guided.active || state.guided.busy;
          dom.guidedStart.disabled = disabled;
        }

        function buildGuidedCommandKey(entry, row) {
          return `${entry.path || entry.file || entry.manufacturer}::${row.name || row.index}`;
        }

        function buildGuidedCandidates(typeId, brand) {
          if (!state.irdb.index.length) return [];
          const normalizedBrand = (brand || "").toLowerCase();

          // Separa candidati in 3 gruppi per priorit√†
          const exactMatches = [];
          const partialMatches = [];
          const otherMatches = [];

          state.irdb.index.forEach((entry) => {
            if (!matchesGuidedCategory(entry, typeId)) {
              return;
            }

            const entryBrand = (entry.manufacturer || "").toLowerCase();

            // Gruppo 1: Match esatto del brand (massima priorit√†)
            if (normalizedBrand && entryBrand === normalizedBrand) {
              exactMatches.push(entry);
            }
            // Gruppo 2: Match parziale del brand (media priorit√†)
            else if (normalizedBrand && (entryBrand.includes(normalizedBrand) || normalizedBrand.includes(entryBrand))) {
              partialMatches.push(entry);
            }
            // Gruppo 3: Stesso tipo ma brand diverso (bassa priorit√†, ma comunque testato)
            else if (!normalizedBrand) {
              otherMatches.push(entry);
            } else {
              // Includi alcuni dataset generici dello stesso tipo
              otherMatches.push(entry);
            }
          });

          // Combina: prima match esatti, poi parziali, poi altri (limitati)
          return [...exactMatches, ...partialMatches, ...otherMatches.slice(0, 10)];
        }

        async function buildGuidedQueue(entry) {
          if (!entry) {
            state.guided.queue = [];
            return;
          }
          if (!state.guided.datasetCache[entry.path]) {
            state.guided.datasetCache[entry.path] = await loadIrdbDatasetQuiet(entry);
          }
          const dataset = state.guided.datasetCache[entry.path] || [];
          const queue = dataset
            .filter((row) => row.conversion && row.conversion.ok && row.conversion.data)
            .filter((row) => !state.guided.testedCommands.has(buildGuidedCommandKey(entry, row)))
            .map((row) => ({
              entry,
              row,
              priority: getGuidedPriorityScore(state.guided.deviceType, row.name),
            }))
            // FILTRO INTELLIGENTE: testa solo comandi ad alta priorit√†
            .filter((item) => item.priority >= GUIDED_MIN_PRIORITY_THRESHOLD)
            .sort((a, b) => {
              if (b.priority !== a.priority) {
                return b.priority - a.priority;
              }
              return (a.row.name || "").localeCompare(b.row.name || "", "it", {
                sensitivity: "base",
              });
            })
            // LIMITA: prendi solo i top N comandi per dataset
            .slice(0, GUIDED_MAX_COMMANDS_PER_DATASET);
          state.guided.queue = queue;
        }

        async function advanceGuidedCandidate(options = {}) {
          const { stayOnCurrent = false, resetIndex = false } = options;
          if (!stayOnCurrent && state.guided.currentHistoryId && state.guided.queue.length === 0) {
            updateGuidedHistoryEntry(state.guided.currentHistoryId, "error", "Nessuna risposta rilevata");
            if (state.guided.currentEntry?.path) {
              saveTestResult(state.guided.currentEntry.path, false);
            }
            state.guided.currentHistoryId = "";
          }
          if (state.guided.lockedEntryPath) {
            const lockedEntry =
              state.guided.candidates.find((entry) => entry.path === state.guided.lockedEntryPath) ||
              state.guided.allCandidates.find((entry) => entry.path === state.guided.lockedEntryPath);
            if (!lockedEntry) {
              return false;
            }
            await buildGuidedQueue(lockedEntry);
            state.guided.currentEntry = lockedEntry;
            if (state.guided.queue.length > 0) {
              handleGuidedDatasetActivation(lockedEntry);
              return true;
            }
            return false;
          }
          if (resetIndex) {
            state.guided.currentCandidateIndex = -1;
          }
          if (!stayOnCurrent) {
            state.guided.currentCandidateIndex += 1;
          }
          const entry = state.guided.candidates[state.guided.currentCandidateIndex];
          if (!entry) {
            state.guided.queue = [];
            return false;
          }
          state.guided.currentEntry = entry;
          await buildGuidedQueue(entry);
          if (state.guided.queue.length > 0) {
            handleGuidedDatasetActivation(entry);
            return true;
          }
          return false;
        }

        function handleGuidedDatasetActivation(entry) {
          const datasetLabel = describeGuidedEntry(entry);
          state.guided.activeDatasetPath = entry.path;
          state.guided.datasetCommandCounter = 0;

          // Calcola progresso
          const currentDataset = state.guided.currentCandidateIndex + 1;
          const totalDatasets = state.guided.candidates.length;
          const progressPercent = Math.round((currentDataset / totalDatasets) * 100);

          if (dom.guidedDatasetLabel) {
            dom.guidedDatasetLabel.textContent = `${datasetLabel} [${currentDataset}/${totalDatasets} - ${progressPercent}%]`;
          }
          updateGuidedBadge(`Test ${currentDataset}/${totalDatasets} (${progressPercent}%)`, "info");
          updateGuidedStatus(`üîç Sto provando ${datasetLabel} (dataset ${currentDataset} di ${totalDatasets})`);
          setGuidedFeedbackVisible(true);
          state.guided.currentHistoryId = pushGuidedHistoryEntry(
            `[${currentDataset}/${totalDatasets}] ${datasetLabel}`,
            "Test automatico in corso..."
          );
        }

        function queueGuidedNextCommand(delay = GUIDED_COMMAND_INTERVAL_MS) {
          if (state.guided.loopHandle) {
            clearTimeout(state.guided.loopHandle);
            state.guided.loopHandle = null;
          }
          state.guided.loopHandle = setTimeout(() => {
            sendNextGuidedCommand();
          }, delay);
        }

        async function sendNextGuidedCommand() {
          if (!state.guided.active) {
            return;
          }
          while (state.guided.active && !state.guided.queue.length) {
            const hasNext = await advanceGuidedCandidate();
            if (!hasNext) {
              // Calcola statistiche finali
              const totalDatasetsTested = state.guided.currentCandidateIndex + 1;
              const totalCommandsSent = state.guided.commandsTested;
              stopGuidedMode(
                `üîç Ricerca completata! Testati ${totalDatasetsTested} dataset (${totalCommandsSent} comandi). Nessun dispositivo compatibile trovato. Prova a cambiare marca/tipo o usa la scansione manuale.`,
                "warning"
              );
              return;
            }
          }
          if (!state.guided.active) {
            return;
          }
          const next = state.guided.queue.shift();
          if (!next || !next.row || !next.row.conversion || !next.row.conversion.data) {
            queueGuidedNextCommand(200);
            return;
          }
          state.guided.currentCommand = next;
          const commandKey = buildGuidedCommandKey(next.entry, next.row);
          state.guided.testedCommands.add(commandKey);
          state.guided.commandsTested += 1;
          state.guided.datasetCommandCounter += 1;
          const datasetLabel = describeGuidedEntry(next.entry);
          if (dom.guidedCurrentCommand) {
            dom.guidedCurrentCommand.textContent = `Ultimo comando: ${next.row.name} (prio: ${next.priority}) ¬∑ ${datasetLabel}`;
          }
          updateGuidedStatus(
            `Sto provando ${datasetLabel} ¬∑ comando ${state.guided.datasetCommandCounter}/${GUIDED_MAX_COMMANDS_PER_DATASET}`
          );

          // AUTO-SKIP RICORSIVO: se abbiamo testato troppi comandi senza risposta, salta al prossimo dataset
          if (state.guided.datasetCommandCounter >= GUIDED_AUTO_SKIP_THRESHOLD) {
            const datasetsRemaining = state.guided.candidates.length - state.guided.currentCandidateIndex - 1;
            updateGuidedStatus(`Nessuna risposta dopo ${GUIDED_AUTO_SKIP_THRESHOLD} comandi. Passo al prossimo dataset (${datasetsRemaining} rimanenti)...`);
            if (state.guided.currentHistoryId) {
              updateGuidedHistoryEntry(
                state.guided.currentHistoryId,
                "error",
                `Auto-skip: ${GUIDED_AUTO_SKIP_THRESHOLD} comandi testati senza risposta`
              );
            }
            // MODALIT√Ä RICORSIVA: continua automaticamente con il prossimo dataset
            if (GUIDED_AUTO_MODE) {
              await skipGuidedDataset();
              // skipGuidedDataset gi√† richiama queueGuidedNextCommand, quindi ritorna
            } else {
              await skipGuidedDataset();
            }
            return;
          }

          try {
            const payload = buildCommandPayloadFromConversion(next.row.conversion.data);
            await dispatchIrPayload(payload, `${next.row.name} ¬∑ ${next.entry.path}`);
          } catch (error) {
            console.error("Guided send error", error);
          }
          if (!state.guided.active) {
            return;
          }
          queueGuidedNextCommand();
        }

        async function startGuidedMode() {
          if (state.guided.active || state.guided.busy) {
            return;
          }
          if (!supportsFetch) {
            showToast("Fetch API non supportata dal browser.", "error");
            return;
          }
          state.guided.busy = true;
          try {
            if (!state.irdb.index.length) {
              if (state.irdb.loadingIndex) {
                showToast("Attendi il completamento del download dell'indice irdb.", "info");
                return;
              }
              await loadIrdbIndex(true);
              if (!state.irdb.index.length) {
                updateGuidedStatus("Indice irdb non disponibile.");
                return;
              }
            }
            const typeId = dom.guidedDeviceType ? dom.guidedDeviceType.value : state.guided.deviceType;
            state.guided.deviceType = typeId;
            const brand = dom.guidedBrand ? dom.guidedBrand.value : state.guided.brand;
            state.guided.brand = brand || "";
            const targetDevice = resolveGuidedTargetDevice();
            if (!targetDevice) {
              showToast("Scegli o crea un dispositivo locale prima di iniziare.", "error");
              updateGuidedStatus("Imposta o seleziona un dispositivo locale per avviare la procedura guidata.");
              return;
            }
            const existed = Boolean(state.ir.devices[targetDevice]);
            ensureDevice(targetDevice);
            if (!existed) {
              markIrDirty();
            }
            state.ir.selectedDevice = targetDevice;
            state.guided.targetDevice = targetDevice;
            syncDeviceSelects();
            renderLocalCommands();
            const candidates = buildGuidedCandidates(typeId, state.guided.brand);
            if (!candidates.length) {
              updateGuidedStatus("Nessun dataset trovato per i criteri selezionati.");
              showToast("Nessun dataset compatibile trovato.", "error");
              return;
            }
            state.guided.active = true;
            state.guided.candidates = candidates.slice();
            state.guided.allCandidates = candidates.slice();
            state.guided.currentCandidateIndex = -1;
            state.guided.lockedEntryPath = "";
            state.guided.queue = [];
            state.guided.history = [];
            state.guided.currentCommand = null;
            state.guided.currentHistoryId = "";
            state.guided.mappedCount = 0;
            state.guided.testedCommands = new Set();
            state.guided.commandsTested = 0;
            state.guided.datasetCommandCounter = 0;
            state.guided.activeDatasetPath = "";
            if (state.guided.loopHandle) {
              clearTimeout(state.guided.loopHandle);
              state.guided.loopHandle = null;
            }
            renderGuidedHistory();
            updateGuidedBadge("Ricerca automatica attiva", "info");
            updateGuidedStatus(
              `ü§ñ Ricerca AUTOMATICA per ${getGuidedLabel(typeId)} (${state.guided.brand || "multi-marca"}) - Tester√≤ ${candidates.length} dataset fino a trovare il tuo dispositivo!`
            );
            setGuidedFeedbackVisible(true);
            showToast(`Avviata ricerca automatica: ${candidates.length} dataset da testare`, "info");
            if (dom.guidedStart) dom.guidedStart.disabled = true;
            if (dom.guidedStop) dom.guidedStop.disabled = false;
            await advanceGuidedCandidate({ resetIndex: true });
            await sendNextGuidedCommand();
          } finally {
            state.guided.busy = false;
            updateGuidedStartButtonState();
          }
        }

        function stopGuidedMode(message = "Procedura interrotta.", type = "info") {
          state.guided.active = false;
          state.guided.queue = [];
          state.guided.currentCommand = null;
          state.guided.currentHistoryId = "";
          state.guided.lockedEntryPath = "";
          state.guided.datasetCommandCounter = 0;
          state.guided.currentEntry = null;
          state.guided.activeDatasetPath = "";
          if (state.guided.loopHandle) {
            clearTimeout(state.guided.loopHandle);
            state.guided.loopHandle = null;
          }
          setGuidedFeedbackVisible(false);
          updateGuidedBadge("Inattiva", type);
          updateGuidedStatus(message);
          if (dom.guidedStart) dom.guidedStart.disabled = false;
          if (dom.guidedStop) dom.guidedStop.disabled = true;
          updateGuidedStartButtonState();
        }

        async function skipGuidedDataset() {
          if (!state.guided.active) return;
          if (state.guided.lockedEntryPath) {
            state.guided.lockedEntryPath = "";
            state.guided.candidates = state.guided.allCandidates.filter(
              (entry) => entry.path !== (state.guided.currentCommand?.entry.path || "")
            );
            state.guided.allCandidates = state.guided.candidates.slice();
            state.guided.currentCandidateIndex = -1;
          }
          state.guided.queue = [];
          state.guided.currentCommand = null;
          state.guided.currentHistoryId = "";
          state.guided.datasetCommandCounter = 0;
          state.guided.currentEntry = null;
          state.guided.activeDatasetPath = "";
          if (state.guided.loopHandle) {
            clearTimeout(state.guided.loopHandle);
            state.guided.loopHandle = null;
          }
          const hasNext = await advanceGuidedCandidate({ stayOnCurrent: false });
          if (!hasNext) {
            stopGuidedMode("Nessun altro dataset disponibile.", "info");
            return;
          }
          queueGuidedNextCommand(200);
        }

        async function handleGuidedFeedback(result) {
          if (!state.guided.active) {
            return;
          }
          const entry = state.guided.currentCommand?.entry || state.guided.currentEntry;
          const historyId = state.guided.currentHistoryId;
          if (result === "skip") {
            updateGuidedHistoryEntry(historyId, "error", "Dataset saltato");
            updateGuidedStatus("Dataset saltato. Cerco alternative...");
            if (entry?.path) {
              saveTestResult(entry.path, false);
            }
            await skipGuidedDataset();
            return;
          }
          if (result === "yes") {
            if (!entry) {
              showToast("Nessun dataset attivo. Attendi la scansione automatica.", "error");
              return;
            }
            const imported = await importGuidedDataset(entry);
            if (imported > 0) {
              // SALVATAGGIO AUTOMATICO dei dati IR su file
              await saveIrData();

              updateGuidedHistoryEntry(
                historyId,
                "success",
                `${imported} comandi importati e salvati su file`
              );
              saveTestResult(entry.path, true);
              stopGuidedMode(
                `‚úÖ Identificato ${describeGuidedEntry(entry)} (${imported} comandi importati e salvati).`,
                "success"
              );
              showToast(
                `‚úÖ Dataset ${describeGuidedEntry(entry)} importato (${imported} comandi salvati su file).`,
                "success"
              );
              return;
            }
            updateGuidedHistoryEntry(historyId, "error", "Nessun comando importato");
            showToast("Il dataset non contiene comandi compatibili da importare.", "error");
            return;
          }
          updateGuidedHistoryEntry(historyId, "error", "Nessuna risposta");
          if (entry?.path) {
            saveTestResult(entry.path, false);
          }
          updateGuidedStatus("Nessuna risposta. Provo un altro dataset.");
          await skipGuidedDataset();
        }

        // ========== FINGERPRINTING & IDENTIFICATION ==========

        function normalizeProtocol(protocol) {
          if (!protocol) return "";
          const p = protocol.toUpperCase().trim();
          if (p.startsWith("NEC")) return "NEC";
          if (p.startsWith("SONY")) return "SONY";
          if (p === "SAMSUNG" || p === "SAMSUNG32") return "SAMSUNG";
          return p;
        }

        function hashRawSequence(rawArray) {
          if (!Array.isArray(rawArray) || rawArray.length === 0) return null;
          const sample = rawArray.slice(0, Math.min(10, rawArray.length));
          return sample.join(",");
        }

        function generateFingerprint(commandData, source = { type: "manual" }) {
          const fp = {
            protocol: normalizeProtocol(commandData.protocol),
            bits: commandData.bits,
            value: commandData.value ? commandData.value.toLowerCase() : null,
            address: commandData.address,
            command: commandData.command,
            device: commandData.device,
            subdevice: commandData.subdevice,
            rawSignature: commandData.raw ? hashRawSequence(commandData.raw) : null,
            source: source,
            timestamp: Date.now(),
          };
          return fp;
        }

        function isCompatibleProtocol(proto1, proto2) {
          const p1 = normalizeProtocol(proto1);
          const p2 = normalizeProtocol(proto2);
          if (p1 === p2) return true;
          if ((p1 === "NEC" && p2 === "NEC") || (p1 === "NEC2" && p2 === "NEC")) return true;
          return false;
        }

        function isInvertedAddress(addr1, addr2) {
          if (addr1 === undefined || addr2 === undefined) return false;
          const a1 = Number(addr1);
          const a2 = Number(addr2);
          if (!Number.isInteger(a1) || !Number.isInteger(a2)) return false;
          const low1 = a1 & 0xff;
          const high1 = (a1 >> 8) & 0xff;
          const low2 = a2 & 0xff;
          const high2 = (a2 >> 8) & 0xff;
          return low1 === low2 && high1 === (low2 ^ 0xff);
        }

        function matchFingerprint(target, candidate) {
          let score = 0;
          const weights = {
            protocol: 20,
            address: 30,
            command: 25,
            bits: 10,
            value: 15,
          };

          if (target.protocol === candidate.protocol) {
            score += weights.protocol;
          } else if (isCompatibleProtocol(target.protocol, candidate.protocol)) {
            score += weights.protocol * 0.5;
          }

          if (target.address !== undefined && candidate.address !== undefined) {
            if (target.address === candidate.address) {
              score += weights.address;
            } else if (target.protocol === "NEC" && isInvertedAddress(target.address, candidate.address)) {
              score += weights.address * 0.7;
            }
          }

          if (target.command !== undefined && candidate.command !== undefined) {
            if (target.command === candidate.command) {
              score += weights.command;
            }
          }

          if (target.bits === candidate.bits) {
            score += weights.bits;
          }

          if (target.value && candidate.value && target.value === candidate.value) {
            score += weights.value;
          }

          return score;
        }

        function scoreDatasetMatch(fingerprints, dataset) {
          if (!Array.isArray(fingerprints) || !Array.isArray(dataset)) {
            return { score: 0, matchCount: 0, matched: [], confidence: 0 };
          }

          const matched = [];
          let totalScore = 0;

          fingerprints.forEach((fp) => {
            let bestMatch = null;
            let bestScore = 0;

            dataset.forEach((row) => {
              if (!row.conversion || !row.conversion.ok) return;
              const candidateFp = {
                protocol: normalizeProtocol(row.conversion.data.protocol),
                bits: row.conversion.data.bits,
                value: row.conversion.data.value,
                address: row.conversion.data.address,
                command: row.conversion.data.command,
                device: row.conversion.data.device,
                subdevice: row.conversion.data.subdevice,
              };

              const matchScore = matchFingerprint(fp, candidateFp);
              if (matchScore > bestScore) {
                bestScore = matchScore;
                bestMatch = { row, score: matchScore };
              }
            });

            if (bestMatch && bestScore >= 30) {
              matched.push(bestMatch);
              totalScore += bestScore;
            }
          });

          const matchCount = matched.length;
          const avgScore = matchCount > 0 ? totalScore / matchCount : 0;
          const confidence = Math.min(100, (matchCount / fingerprints.length) * avgScore);

          return {
            score: totalScore,
            matchCount,
            matched,
            confidence: Math.round(confidence),
          };
        }

        function buildDeviceProfile(deviceName) {
          const commands = state.ir.devices[deviceName] || {};
          const profile = {
            protocol: {},
            addresses: {},
            commands: [],
            totalCommands: 0,
          };

          Object.entries(commands).forEach(([name, data]) => {
            const fp = generateFingerprint(data, { type: "manual" });

            profile.protocol[fp.protocol] = (profile.protocol[fp.protocol] || 0) + 1;
            if (fp.address !== undefined) {
              const addrKey = `0x${fp.address.toString(16)}`;
              profile.addresses[addrKey] = (profile.addresses[addrKey] || 0) + 1;
            }
            profile.commands.push(fp);
            profile.totalCommands++;
          });

          const dominantProtocol = Object.entries(profile.protocol)
            .sort((a, b) => b[1] - a[1])[0];
          const protocolConsistency = dominantProtocol ? dominantProtocol[1] / profile.totalCommands : 0;

          profile.confidence = Math.min(100, Math.round(profile.totalCommands * 10 * protocolConsistency));
          profile.dominantProtocol = dominantProtocol ? dominantProtocol[0] : null;

          console.log("Device profile built:", deviceName, profile);

          return profile;
        }

        function updateIdentificationBadge(text, type = "info") {
          if (!dom.identificationBadge) return;
          dom.identificationBadge.textContent = text;
          dom.identificationBadge.className = `badge ${type}`;
        }

        function updateIdentificationStatus(text) {
          if (!dom.identificationStatus) return;
          dom.identificationStatus.textContent = text;
        }

        function renderIdentificationResults() {
          if (!dom.identificationResults) return;

          if (!state.irFingerprinting.matches.length) {
            dom.identificationResults.innerHTML =
              '<div class="muted">Nessun dataset compatibile trovato. Prova con pi√π comandi o un metodo diverso.</div>';
            return;
          }

          const markup = state.irFingerprinting.matches
            .map((match, idx) => {
              const confidence = match.confidence || 0;
              const badgeClass = confidence >= 70 ? "success" : confidence >= 40 ? "info" : "error";

              return `
                <div class="list-item" data-match-index="${idx}">
                  <div class="flex-row" style="justify-content: space-between;">
                    <div>
                      <strong>${escapeHtml(match.entry.manufacturer)} - ${escapeHtml(match.entry.file)}</strong>
                      <div class="muted">${escapeHtml(match.entry.category || "")}</div>
                    </div>
                    <span class="badge ${badgeClass}">
                      ${confidence}% ¬∑ ${match.matchCount} match
                    </span>
                  </div>
                  <div class="actions-bar">
                    <button class="primary-btn" data-action="import-match" data-match-index="${idx}">
                      <i class="fas fa-download"></i>Importa dataset
                    </button>
                    <button class="secondary-btn" data-action="preview-match" data-match-index="${idx}">
                      <i class="fas fa-eye"></i>Anteprima
                    </button>
                  </div>
                </div>
              `;
            })
            .join("");

          dom.identificationResults.innerHTML = `
            <div class="stacked" style="gap: 10px; margin-top: 15px;">
              <div class="muted">
                <i class="fas fa-check-circle"></i>
                Trovati ${state.irFingerprinting.matches.length} dataset compatibili. I migliori risultati:
              </div>
              ${markup}
            </div>
          `;
        }

        async function loadIrdbDatasetQuiet(entry) {
          if (!entry) return [];
          try {
            const response = await fetch(`${IRDB_CODES_BASE_URL}${entry.path}`, {
              cache: "default",
            });
            if (!response.ok) return [];
            const text = await response.text();
            return parseIrdbCsv(text);
          } catch (error) {
            console.error("Dataset load error", error);
            return [];
          }
        }

        async function processScannedIrCode(irData) {
          if (!state.irFingerprinting.scanning) return;

          const fp = generateFingerprint(irData, { type: "scan" });
          state.irFingerprinting.scannedCodes.push(fp);

          const count = state.irFingerprinting.scannedCodes.length;
          updateIdentificationBadge(`${count} codici`, "info");
          updateIdentificationStatus(
            `Codice ${count} acquisito (${fp.protocol}, ${fp.bits} bit). ` +
            (count >= 3 ? "Avvio identificazione..." : `Premi altri ${3 - count} tasti.`)
          );

          console.log("Scanned code:", fp);

          if (count >= 3) {
            state.irFingerprinting.scanning = false;
            await performIdentificationFromScan();
          }
        }

        async function performIdentificationFromScan() {
          const fingerprints = state.irFingerprinting.scannedCodes;

          updateIdentificationBadge("Identificazione...", "info");
          updateIdentificationStatus("Caricamento indice IRDB...");

          await loadIrdbIndex();

          if (!state.irdb.index.length) {
            showToast("Indice IRDB non disponibile. Caricalo prima.", "error");
            updateIdentificationBadge("Errore", "error");
            return;
          }

          const protocols = [...new Set(fingerprints.map(fp => fp.protocol))];
          const dominantProtocol = protocols[0];

          console.log("Scanned protocols:", protocols, "dominant:", dominantProtocol);

          const categoryHints = {
            "NEC": ["TV", "Audio", "Video", "Receiver", "DVD", "Blu-ray", "LED"],
            "SONY": ["TV", "Audio", "Projector", "Video", "DVD"],
            "SAMSUNG": ["TV", "AirConditioner", "DVD"],
          };

          let candidateEntries = state.irdb.index.filter((entry) => {
            const hints = categoryHints[dominantProtocol] || [];
            return hints.some((cat) => entry.category?.toLowerCase().includes(cat.toLowerCase()));
          });

          if (candidateEntries.length === 0) {
            candidateEntries = state.irdb.index.slice(0, 100);
          }

          console.log("Candidate entries for scan:", candidateEntries.length);

          updateIdentificationStatus(`Testando ${Math.min(50, candidateEntries.length)} dataset candidati...`);

          const matches = [];
          const testLimit = Math.min(50, candidateEntries.length);

          for (let i = 0; i < testLimit; i++) {
            const entry = candidateEntries[i];
            const dataset = await loadIrdbDatasetQuiet(entry);
            const matchScore = scoreDatasetMatch(fingerprints, dataset);

            console.log(`Scan dataset ${entry.manufacturer}/${entry.file}: ${matchScore.matchCount} matches, confidence ${matchScore.confidence}%`);

            if (matchScore.matchCount >= 1) {
              matches.push({ entry, ...matchScore });
            }

            if (i % 10 === 0) {
              updateIdentificationStatus(`Testati ${i + 1}/${testLimit} dataset...`);
            }
          }

          matches.sort((a, b) => b.confidence - a.confidence || b.score - a.score);
          state.irFingerprinting.matches = matches.slice(0, 5);

          if (matches.length > 0) {
            updateIdentificationBadge(`${matches.length} trovati`, "success");
            updateIdentificationStatus(`Identificazione completata! Trovati ${matches.length} dataset compatibili.`);
            showToast(`Trovati ${matches.length} dataset compatibili da scansione!`, "success");
          } else {
            updateIdentificationBadge("Nessun match", "error");
            updateIdentificationStatus("Nessun dataset compatibile trovato dalla scansione.");
            showToast("Nessun dataset IRDB compatibile trovato.", "error");
          }

          renderIdentificationResults();
        }

        async function identifyDeviceFromScan() {
          // Usa i codici gi√† acquisiti nel tab IR Scan
          if (!state.irScan.scannedCodes || state.irScan.scannedCodes.length < 2) {
            showToast("Acquisisci almeno 2-3 codici IR prima di identificare.", "error");
            return;
          }

          const fingerprints = state.irScan.scannedCodes.map((code) =>
            generateFingerprint(code, { type: "scan" })
          );

          state.irFingerprinting.identifying = true;
          updateIdentificationBadge("Identificazione...", "info");
          updateIdentificationStatus(`Analizzando ${fingerprints.length} codici acquisiti...`);

          await loadIrdbIndex();

          if (!state.irdb.index.length) {
            showToast("Indice IRDB non disponibile. Caricalo prima dal tab IR.", "error");
            state.irFingerprinting.identifying = false;
            updateIdentificationBadge("Errore", "error");
            return;
          }

          // Determina protocollo dominante
          const protocolCounts = {};
          fingerprints.forEach((fp) => {
            protocolCounts[fp.protocol] = (protocolCounts[fp.protocol] || 0) + 1;
          });

          const dominantProtocol = Object.keys(protocolCounts).sort(
            (a, b) => protocolCounts[b] - protocolCounts[a]
          )[0];

          console.log("Dominant protocol from scan:", dominantProtocol);

          // Filtra candidati IRDB per categoria/protocollo
          const categoryHints = {
            NEC: ["tv", "audio", "video", "projector"],
            SAMSUNG: ["tv", "audio", "video"],
            SONY: ["tv", "audio", "video", "camera"],
            RC5: ["tv", "audio", "video"],
            RC6: ["tv", "audio", "video"],
          };

          let candidateEntries = state.irdb.index.filter((entry) => {
            const hints = categoryHints[dominantProtocol] || [];
            return hints.some((cat) =>
              entry.category?.toLowerCase().includes(cat.toLowerCase())
            );
          });

          // Fallback se nessun candidato
          if (candidateEntries.length === 0) {
            candidateEntries = state.irdb.index.filter(
              (entry) =>
                entry.category?.toLowerCase().includes("tv") ||
                entry.category?.toLowerCase().includes("audio") ||
                entry.category?.toLowerCase().includes("video")
            );
          }

          console.log(`Testing ${candidateEntries.length} candidate datasets`);

          const testLimit = Math.min(50, candidateEntries.length);
          const matches = [];

          for (let i = 0; i < testLimit; i++) {
            const entry = candidateEntries[i];
            const dataset = await loadIrdbDatasetQuiet(entry);
            const matchScore = scoreDatasetMatch(fingerprints, dataset);

            console.log(
              `Scan dataset ${entry.manufacturer}/${entry.file}: ${matchScore.matchCount} matches, confidence ${matchScore.confidence}%`
            );

            if (matchScore.matchCount >= 1) {
              matches.push({ entry, ...matchScore });
            }

            if (i % 10 === 0) {
              updateIdentificationStatus(`Testati ${i + 1}/${testLimit} dataset...`);
            }
          }

          state.irFingerprinting.identifying = false;
          matches.sort((a, b) => b.confidence - a.confidence || b.score - a.score);
          state.irFingerprinting.matches = matches.slice(0, 5);

          if (matches.length > 0) {
            updateIdentificationBadge(`${matches.length} trovati`, "success");
            updateIdentificationStatus(
              `Identificazione completata! Trovati ${matches.length} dataset compatibili.`
            );
            showToast(`Trovati ${matches.length} dataset compatibili!`, "success");
          } else {
            updateIdentificationBadge("Nessun match", "error");
            updateIdentificationStatus("Nessun dataset compatibile trovato.");
            showToast("Nessun dataset IRDB compatibile trovato.", "error");
          }

          renderIdentificationResults();
        }

        async function identifyDeviceFromProfile() {
          if (!state.ir.selectedDevice) {
            showToast("Seleziona un dispositivo con comandi esistenti.", "error");
            return;
          }

          const profile = buildDeviceProfile(state.ir.selectedDevice);

          if (profile.totalCommands < 3) {
            showToast("Servono almeno 3 comandi per l'identificazione automatica.", "error");
            return;
          }

          state.irFingerprinting.identifying = true;
          updateIdentificationBadge("Identificazione...", "info");
          updateIdentificationStatus(`Analizzando ${profile.totalCommands} comandi del dispositivo ${state.ir.selectedDevice}...`);

          await loadIrdbIndex();

          if (!state.irdb.index.length) {
            showToast("Indice IRDB non disponibile. Caricalo prima.", "error");
            state.irFingerprinting.identifying = false;
            updateIdentificationBadge("Errore", "error");
            return;
          }

          const dominantProtocol = Object.keys(profile.protocol)
            .sort((a, b) => profile.protocol[b] - profile.protocol[a])[0];

          const categoryHints = {
            "NEC": ["TV", "Audio", "Video", "Receiver", "DVD", "Blu-ray"],
            "SONY": ["TV", "Audio", "Projector", "Video", "DVD"],
            "SAMSUNG": ["TV", "AirConditioner", "DVD"],
          };

          let candidateEntries = state.irdb.index.filter((entry) => {
            const hints = categoryHints[dominantProtocol] || [];
            return hints.some((cat) => entry.category?.toLowerCase().includes(cat.toLowerCase()));
          });

          if (candidateEntries.length === 0) {
            candidateEntries = state.irdb.index.filter((entry) =>
              entry.category?.toLowerCase().includes("tv") ||
              entry.category?.toLowerCase().includes("audio") ||
              entry.category?.toLowerCase().includes("video")
            );
          }

          console.log("Candidate entries:", candidateEntries.length, "for protocol", dominantProtocol);

          updateIdentificationStatus(`Testando ${Math.min(50, candidateEntries.length)} dataset candidati...`);

          const matches = [];
          const testLimit = Math.min(50, candidateEntries.length);

          for (let i = 0; i < testLimit; i++) {
            const entry = candidateEntries[i];
            const dataset = await loadIrdbDatasetQuiet(entry);
            const matchScore = scoreDatasetMatch(profile.commands, dataset);

            console.log(`Dataset ${entry.manufacturer}/${entry.file}: ${matchScore.matchCount} matches, confidence ${matchScore.confidence}%`);

            if (matchScore.matchCount >= 1) {
              matches.push({ entry, ...matchScore });
            }

            if (i % 10 === 0) {
              updateIdentificationStatus(`Testati ${i + 1}/${testLimit} dataset...`);
            }
          }

          matches.sort((a, b) => b.confidence - a.confidence || b.score - a.score);
          state.irFingerprinting.matches = matches.slice(0, 5);

          state.irFingerprinting.identifying = false;

          if (matches.length > 0) {
            updateIdentificationBadge(`${matches.length} trovati`, "success");
            updateIdentificationStatus(`Identificazione completata! Trovati ${matches.length} dataset compatibili.`);
            showToast(`Trovati ${matches.length} dataset compatibili!`, "success");
          } else {
            updateIdentificationBadge("Nessun match", "error");
            updateIdentificationStatus("Nessun dataset compatibile trovato. Prova a importare pi√π comandi o usa la scansione diretta.");
            showToast("Nessun dataset IRDB compatibile trovato.", "error");
          }

          renderIdentificationResults();
        }

        function handleIdentificationResultClick(event) {
          const importBtn = event.target.closest("[data-action='import-match']");
          const previewBtn = event.target.closest("[data-action='preview-match']");

          if (importBtn) {
            const index = Number(importBtn.getAttribute("data-match-index"));
            const match = state.irFingerprinting.matches[index];
            if (!match) return;

            state.irdb.selectedEntry = match.entry;
            renderIrdbResults();
            loadIrdbDataset(match.entry);

            showToast(`Dataset ${match.entry.manufacturer} caricato. Seleziona i comandi da importare.`, "success");

            const irdbCard = document.getElementById("irdbDatasetCard");
            if (irdbCard) {
              irdbCard.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          }

          if (previewBtn) {
            const index = Number(previewBtn.getAttribute("data-match-index"));
            const match = state.irFingerprinting.matches[index];
            if (!match) return;

            const matchedCommands = match.matched.map((m) => m.row.name).join(", ");
            alert(
              `Dataset: ${match.entry.manufacturer} - ${match.entry.file}\n` +
              `Categoria: ${match.entry.category}\n` +
              `Confidence: ${match.confidence}%\n` +
              `Match: ${match.matchCount} comandi\n\n` +
              `Comandi corrispondenti:\n${matchedCommands}`
            );
          }
        }

        function loadTestResultsFromLocalStorage() {
          try {
            const keys = Object.keys(localStorage);
            keys.forEach((key) => {
              if (key.startsWith("irdb_test_")) {
                const path = atob(key.replace("irdb_test_", ""));
                const data = JSON.parse(localStorage.getItem(key) || "{}");
                state.irFingerprinting.testResults[path] = data;
              }
            });
          } catch (error) {
            console.error("Error loading test results", error);
          }
        }

        function saveTestResult(irdbPath, success) {
          try {
            const key = `irdb_test_${btoa(irdbPath)}`;
            const existing = JSON.parse(localStorage.getItem(key) || '{"success": 0, "failed": 0}');

            if (success) {
              existing.success = (existing.success || 0) + 1;
            } else {
              existing.failed = (existing.failed || 0) + 1;
            }

            existing.lastTested = Date.now();
            localStorage.setItem(key, JSON.stringify(existing));

            state.irFingerprinting.testResults[irdbPath] = existing;
          } catch (error) {
            console.error("Error saving test result", error);
          }
        }

        // ========== IR SCAN TAB FUNCTIONS ==========

        function syncScanDeviceSelect() {
          console.log("[IR SCAN] syncScanDeviceSelect() called");
          if (!dom.scanTargetDevice) {
            console.error("[IR SCAN] scanTargetDevice element not found!");
            return;
          }
          const names = getDeviceNames();
          console.log("[IR SCAN] Available devices:", names);
          dom.scanTargetDevice.innerHTML = names.length
            ? [""].concat(names)
                .map((name) =>
                  name
                    ? `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`
                    : '<option value="">Seleziona dispositivo...</option>'
                )
                .join("")
            : '<option value="">Nessun dispositivo</option>';
          dom.scanTargetDevice.value = state.irScan.targetDevice || "";
          console.log("[IR SCAN] Device select synced, current value:", dom.scanTargetDevice.value);
        }

        function updateScanModeBadge(text, type = "info") {
          if (!dom.scanModeBadge) return;
          dom.scanModeBadge.textContent = text;
          dom.scanModeBadge.className = `badge ${type}`;
        }

        function updateScanStatus(text) {
          if (!dom.scanStatus) return;
          dom.scanStatus.textContent = text;
        }

        function updateScannedCountBadge() {
          if (!dom.scannedCountBadge) return;
          const count = state.irScan.scannedCodes.length;
          dom.scannedCountBadge.textContent = `${count} codici`;
        }

        function renderScannedCodes() {
          if (!dom.scannedCodesContainer) return;

          if (state.irScan.scannedCodes.length === 0) {
            dom.scannedCodesContainer.innerHTML =
              '<div class="muted">Nessun codice acquisito. Avvia la scansione.</div>';
            return;
          }

          const markup = state.irScan.scannedCodes
            .map((code, index) => {
              const proto = code.protocol || "-";
              const bits = code.bits || "-";
              const value = code.value ? `0x${code.value}` : "-";
              const name = code.name || `cmd_${index + 1}`;

              return `
                <div class="list-item" data-scan-index="${index}">
                  <div class="flex-row" style="justify-content: space-between;">
                    <div>
                      <strong>${escapeHtml(name)}</strong>
                      <div class="muted">${escapeHtml(proto)} ¬∑ ${bits} bit</div>
                      <div class="muted">${escapeHtml(value)}</div>
                    </div>
                    <div class="actions-bar">
                      <button class="secondary-btn" data-scan-action="rename" data-scan-index="${index}" title="Rinomina">
                        <i class="fas fa-i-cursor"></i>
                      </button>
                      <button class="danger-btn" data-scan-action="delete" data-scan-index="${index}" title="Elimina">
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </div>
                </div>
              `;
            })
            .join("");

          dom.scannedCodesContainer.innerHTML = markup;
        }

        async function startScanMode() {
          console.log("[IR SCAN] startScanMode() called");

          const newDevice = dom.scanNewDeviceName ? dom.scanNewDeviceName.value.trim() : "";
          const selectedDevice = dom.scanTargetDevice ? dom.scanTargetDevice.value : "";
          console.log("[IR SCAN] Input values:", { newDevice, selectedDevice });

          let targetDevice = "";
          if (newDevice) {
            targetDevice = sanitizeDeviceName(newDevice);
            if (!targetDevice) {
              showToast("Nome dispositivo non valido.", "error");
              return;
            }
          } else if (selectedDevice) {
            targetDevice = selectedDevice;
          } else {
            showToast("Seleziona o crea un dispositivo di destinazione.", "error");
            return;
          }

          // Chiama l'endpoint per attivare lo scan mode lato firmware
          console.log("[IR SCAN] Calling /special_action endpoint to activate IR scan");
          try {
            const response = await fetch("/special_action", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                actionId: "toggle_ir_scan",
                params: { active: true }
              })
            });

            if (!response.ok) {
              throw new Error("Failed to activate IR scan mode");
            }

            console.log("[IR SCAN] Firmware scan mode activated successfully");
          } catch (error) {
            console.error("[IR SCAN] Error activating firmware scan mode:", error);
            showToast("Errore attivazione ricevitore IR", "error");
            return;
          }

          state.irScan.active = true;
          state.irScan.targetDevice = targetDevice;

          updateScanModeBadge("Attivo", "success");
          updateScanStatus("In ascolto...");
          if (dom.startScanMode) dom.startScanMode.disabled = true;
          if (dom.stopScanMode) dom.stopScanMode.disabled = false;
          if (dom.scanInstructions) {
            dom.scanInstructions.textContent =
              `Modalit√† acquisizione attiva per "${targetDevice}". Premi i tasti del telecomando!`;
          }

          showToast(`Acquisizione avviata per ${targetDevice}`, "success");
        }

        async function stopScanMode() {
          // Chiama l'endpoint per disattivare lo scan mode lato firmware
          console.log("[IR SCAN] Calling /special_action endpoint to deactivate IR scan");
          try {
            const response = await fetch("/special_action", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                actionId: "toggle_ir_scan",
                params: { active: false }
              })
            });

            if (!response.ok) {
              throw new Error("Failed to deactivate IR scan mode");
            }

            console.log("[IR SCAN] Firmware scan mode deactivated successfully");
          } catch (error) {
            console.error("[IR SCAN] Error deactivating firmware scan mode:", error);
          }

          state.irScan.active = false;

          updateScanModeBadge("Inattivo", "info");
          updateScanStatus("Pronto");
          if (dom.startScanMode) dom.startScanMode.disabled = false;
          if (dom.stopScanMode) dom.stopScanMode.disabled = true;
          if (dom.scanInstructions) {
            dom.scanInstructions.textContent =
              "Seleziona un dispositivo di destinazione e avvia l'acquisizione.";
          }

          showToast("Acquisizione fermata.", "info");
        }

        function clearScannedCodes() {
          if (!window.confirm("Eliminare tutti i codici acquisiti?")) return;
          state.irScan.scannedCodes = [];
          renderScannedCodes();
          updateScannedCountBadge();
          if (dom.saveScannedCodes) dom.saveScannedCodes.disabled = true;
          if (dom.identifyFromScan) dom.identifyFromScan.disabled = true;
          updateIdentificationStatus(
            "Acquisisci almeno 2-3 codici IR e poi clicca 'Usa codici acquisiti' per identificare automaticamente il dataset IRDB migliore."
          );
          showToast("Lista svuotata.", "success");
        }

        function saveScannedCodes() {
          if (!state.irScan.targetDevice) {
            showToast("Nessun dispositivo di destinazione.", "error");
            return;
          }

          if (state.irScan.scannedCodes.length === 0) {
            showToast("Nessun codice da salvare.", "error");
            return;
          }

          const deviceCommands = ensureDevice(state.irScan.targetDevice);
          let saved = 0;

          state.irScan.scannedCodes.forEach((code) => {
            const commandName = code.name || `scanned_${Date.now()}_${saved}`;
            const sanitized = sanitizeCommandName(commandName);

            if (deviceCommands[sanitized]) {
              console.log(`Command ${sanitized} already exists, skipping`);
              return;
            }

            const payload = {
              protocol: code.protocol,
              bits: code.bits,
              value: code.value,
              address: code.address,
              command: code.command,
              device: code.device,
              subdevice: code.subdevice,
              source: { type: "scan" },
            };

            if (code.raw) {
              payload.raw = code.raw;
            }

            deviceCommands[sanitized] = payload;
            saved++;
          });

          markIrDirty();
          state.ir.selectedDevice = state.irScan.targetDevice;
          syncDeviceSelects();
          renderLocalCommands();

          showToast(`${saved} comandi salvati in ${state.irScan.targetDevice}.`, "success");

          state.irScan.scannedCodes = [];
          renderScannedCodes();
          updateScannedCountBadge();
          if (dom.saveScannedCodes) dom.saveScannedCodes.disabled = true;
        }

        function handleScannedCodeAction(event) {
          const button = event.target.closest("[data-scan-action]");
          if (!button) return;

          const action = button.getAttribute("data-scan-action");
          const index = Number(button.getAttribute("data-scan-index"));
          const code = state.irScan.scannedCodes[index];

          if (!code) return;

          if (action === "rename") {
            const newName = window.prompt("Nuovo nome comando:", code.name || `cmd_${index + 1}`);
            if (newName && newName.trim()) {
              code.name = sanitizeCommandName(newName);
              renderScannedCodes();
            }
          }

          if (action === "delete") {
            if (!window.confirm(`Eliminare il comando ${code.name || index + 1}?`)) return;
            state.irScan.scannedCodes.splice(index, 1);
            renderScannedCodes();
            updateScannedCountBadge();
            if (state.irScan.scannedCodes.length === 0) {
              if (dom.saveScannedCodes) dom.saveScannedCodes.disabled = true;
              if (dom.identifyFromScan) dom.identifyFromScan.disabled = true;
            }
            if (state.irScan.scannedCodes.length < 2 && dom.identifyFromScan) {
              dom.identifyFromScan.disabled = true;
            }
          }
        }

        function processScannedIrCodeForTab(irData) {
          console.log("[IR SCAN] processScannedIrCodeForTab() called with:", irData);
          console.log("[IR SCAN] state.irScan.active:", state.irScan.active);

          // PRIORITY: Check if custom remote is in learning mode
          if (state.customRemote && state.customRemote.learningActive && window.customRemoteLearnHandler) {
            console.log("[CUSTOM REMOTE] Learning mode active, routing to learn handler");
            window.customRemoteLearnHandler(irData);
            return;
          }

          if (!state.irScan.active) {
            console.log("[IR SCAN] Scan mode not active, ignoring IR code");
            return;
          }

          const code = {
            protocol: irData.protocol,
            bits: irData.bits,
            value: irData.value,
            address: irData.address,
            command: irData.command,
            device: irData.device,
            subdevice: irData.subdevice,
            raw: irData.raw,
            name: `cmd_${state.irScan.scannedCodes.length + 1}`,
            timestamp: Date.now(),
          };

          console.log("[IR SCAN] Created code object:", code);
          state.irScan.scannedCodes.push(code);
          console.log("[IR SCAN] Total scanned codes:", state.irScan.scannedCodes.length);

          renderScannedCodes();
          updateScannedCountBadge();
          updateScanStatus(`${state.irScan.scannedCodes.length} codici acquisiti`);

          if (dom.saveScannedCodes) dom.saveScannedCodes.disabled = false;

          // Abilita identificazione se abbiamo almeno 2 codici
          if (state.irScan.scannedCodes.length >= 2) {
            if (dom.identifyFromScan) {
              dom.identifyFromScan.disabled = false;
            }
            updateIdentificationStatus(
              `${state.irScan.scannedCodes.length} codici acquisiti. Clicca "Usa codici acquisiti" per identificare il dataset IRDB.`
            );
          }

          console.log("[IR SCAN] IR code added to scan tab:", code);
        }

        function initializeIrModule() {
          loadLocalIrData();
          updateIrDirtyUI();
          if (dom.irCommandsContainer) {
            dom.irCommandsContainer.addEventListener("click", handleIrCommandClick);
          }
          if (dom.irManualForm) {
            dom.irManualForm.addEventListener("submit", handleManualSubmit);
          }
        }

        // ========== CUSTOM REMOTE CONTROL FUNCTIONS ==========

        const REMOTE_LAYOUTS = {
          tv: {
            name: "TV",
            buttons: [
              { id: "power", label: "POWER", icon: "fa-power-off", color: "#e74c3c", row: 0 },
              { id: "mute", label: "MUTE", icon: "fa-volume-mute", color: "#95a5a6", row: 0 },
              { id: "input", label: "INPUT", icon: "fa-desktop", color: "#3498db", row: 1 },
              { id: "menu", label: "MENU", icon: "fa-bars", color: "#3498db", row: 1 },
              { id: "up", label: "‚Üë", icon: "fa-arrow-up", color: "#34495e", row: 2 },
              { id: "left", label: "‚Üê", icon: "fa-arrow-left", color: "#34495e", row: 3 },
              { id: "ok", label: "OK", icon: "fa-check-circle", color: "#27ae60", row: 3 },
              { id: "right", label: "‚Üí", icon: "fa-arrow-right", color: "#34495e", row: 3 },
              { id: "down", label: "‚Üì", icon: "fa-arrow-down", color: "#34495e", row: 4 },
              { id: "back", label: "BACK", icon: "fa-arrow-left", color: "#7f8c8d", row: 5 },
              { id: "home", label: "HOME", icon: "fa-home", color: "#7f8c8d", row: 5 },
              { id: "vol_up", label: "VOL+", icon: "fa-volume-up", color: "#9b59b6", row: 6 },
              { id: "ch_up", label: "CH+", icon: "fa-chevron-up", color: "#9b59b6", row: 6 },
              { id: "vol_down", label: "VOL-", icon: "fa-volume-down", color: "#9b59b6", row: 7 },
              { id: "ch_down", label: "CH-", icon: "fa-chevron-down", color: "#9b59b6", row: 7 },
            ]
          },
          led: {
            name: "LED Strip",
            buttons: [
              { id: "power", label: "ON/OFF", icon: "fa-power-off", color: "#e74c3c", row: 0 },
              { id: "bright_up", label: "BRIGHT+", icon: "fa-sun", color: "#f39c12", row: 1 },
              { id: "bright_down", label: "BRIGHT-", icon: "fa-adjust", color: "#f39c12", row: 1 },
              { id: "red", label: "RED", icon: "fa-square", color: "#e74c3c", row: 2 },
              { id: "green", label: "GREEN", icon: "fa-square", color: "#2ecc71", row: 2 },
              { id: "blue", label: "BLUE", icon: "fa-square", color: "#3498db", row: 2 },
              { id: "white", label: "WHITE", icon: "fa-square", color: "#ecf0f1", row: 3 },
              { id: "orange", label: "ORANGE", icon: "fa-square", color: "#e67e22", row: 3 },
              { id: "cyan", label: "CYAN", icon: "fa-square", color: "#1abc9c", row: 3 },
              { id: "mode", label: "MODE", icon: "fa-sync", color: "#9b59b6", row: 4 },
              { id: "speed_up", label: "SPEED+", icon: "fa-forward", color: "#95a5a6", row: 5 },
              { id: "speed_down", label: "SPEED-", icon: "fa-backward", color: "#95a5a6", row: 5 },
            ]
          },
          clima: {
            name: "Climatizzatore",
            buttons: [
              { id: "power", label: "ON/OFF", icon: "fa-power-off", color: "#e74c3c", row: 0 },
              { id: "mode", label: "MODE", icon: "fa-sync-alt", color: "#3498db", row: 1 },
              { id: "fan", label: "FAN", icon: "fa-fan", color: "#3498db", row: 1 },
              { id: "temp_up", label: "TEMP+", icon: "fa-thermometer-full", color: "#e74c3c", row: 2 },
              { id: "temp_down", label: "TEMP-", icon: "fa-thermometer-empty", color: "#3498db", row: 3 },
              { id: "swing", label: "SWING", icon: "fa-arrows-alt-v", color: "#95a5a6", row: 4 },
              { id: "timer", label: "TIMER", icon: "fa-clock", color: "#95a5a6", row: 4 },
              { id: "eco", label: "ECO", icon: "fa-leaf", color: "#27ae60", row: 5 },
              { id: "turbo", label: "TURBO", icon: "fa-bolt", color: "#f39c12", row: 5 },
            ]
          },
          audio: {
            name: "Audio/Receiver",
            buttons: [
              { id: "power", label: "POWER", icon: "fa-power-off", color: "#e74c3c", row: 0 },
              { id: "mute", label: "MUTE", icon: "fa-volume-mute", color: "#95a5a6", row: 0 },
              { id: "source", label: "SOURCE", icon: "fa-random", color: "#3498db", row: 1 },
              { id: "vol_up", label: "VOL+", icon: "fa-volume-up", color: "#9b59b6", row: 2 },
              { id: "vol_down", label: "VOL-", icon: "fa-volume-down", color: "#9b59b6", row: 3 },
              { id: "play", label: "PLAY", icon: "fa-play", color: "#27ae60", row: 4 },
              { id: "pause", label: "PAUSE", icon: "fa-pause", color: "#f39c12", row: 4 },
              { id: "stop", label: "STOP", icon: "fa-stop", color: "#e74c3c", row: 4 },
              { id: "prev", label: "PREV", icon: "fa-step-backward", color: "#34495e", row: 5 },
              { id: "next", label: "NEXT", icon: "fa-step-forward", color: "#34495e", row: 5 },
              { id: "bass_up", label: "BASS+", icon: "fa-music", color: "#e67e22", row: 6 },
              { id: "bass_down", label: "BASS-", icon: "fa-music", color: "#e67e22", row: 6 },
            ]
          },
          custom: {
            name: "Personalizzato",
            buttons: []
          }
        };

        function updateRemoteTypeName() {
          const type = dom.remoteType.value;
          const layout = REMOTE_LAYOUTS[type];
          if (layout && dom.remoteTypeName) {
            dom.remoteTypeName.textContent = layout.name;
          }
        }

        function createNewRemote() {
          const sourceDevice = dom.remoteDeviceSelect.value;
          if (!sourceDevice) {
            showToast("Seleziona prima un dispositivo sorgente", "error");
            return;
          }

          state.customRemote.remoteType = dom.remoteType.value;
          state.customRemote.sourceDevice = sourceDevice;
          state.customRemote.buttons = {};
          state.customRemote.currentRemote = {
            name: `Remote_${sourceDevice}_${Date.now()}`,
            type: state.customRemote.remoteType,
            sourceDevice: sourceDevice,
            buttons: {}
          };

          // Initialize with default layout
          const layout = REMOTE_LAYOUTS[state.customRemote.remoteType];
          if (layout) {
            layout.buttons.forEach(btn => {
              state.customRemote.buttons[btn.id] = {
                ...btn,
                command: null
              };
            });
          }

          dom.remoteBuilderContainer.style.display = "block";
          dom.saveRemoteBtn.disabled = false;
          updateRemoteTypeName();
          renderRemotePreview();
          updateBindCommandSelect();
          showToast("Telecomando creato! Configura i tasti", "success");
        }

        function renderRemotePreview() {
          if (!dom.remotePreview) return;

          const buttons = Object.values(state.customRemote.buttons);
          if (buttons.length === 0) {
            dom.remotePreview.innerHTML = '<div class="muted" style="text-align: center;">Nessun tasto disponibile</div>';
            return;
          }

          // Group buttons by row
          const rows = {};
          buttons.forEach(btn => {
            if (!rows[btn.row]) rows[btn.row] = [];
            rows[btn.row].push(btn);
          });

          let html = '';
          Object.keys(rows).sort((a, b) => a - b).forEach(rowIndex => {
            html += '<div style="display: flex; gap: 8px; margin-bottom: 8px; justify-content: center; flex-wrap: wrap;">';
            rows[rowIndex].forEach(btn => {
              const bound = btn.command ? 'bound' : '';
              const boundColor = btn.command ? 'border: 2px solid #27ae60;' : '';
              const tooltip = btn.command ? `title="Comando: ${btn.command} | Ctrl+Click per inviare"` : '';
              html += `
                <button
                  class="remote-button ${bound}"
                  data-button-id="${btn.id}"
                  ${tooltip}
                  style="
                    min-width: 70px;
                    padding: 12px 16px;
                    border-radius: 8px;
                    background-color: ${btn.color};
                    color: white;
                    border: none;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 0.85rem;
                    transition: all 0.2s;
                    ${boundColor}
                  "
                  onclick="selectRemoteButton('${btn.id}', event)"
                >
                  <i class="fas ${btn.icon}" style="display: block; font-size: 1.2rem; margin-bottom: 4px;"></i>
                  ${btn.label}
                </button>
              `;
            });
            html += '</div>';
          });

          dom.remotePreview.innerHTML = html;
        }

        window.selectRemoteButton = function(buttonId, event) {
          state.customRemote.selectedButton = buttonId;
          const btn = state.customRemote.buttons[buttonId];

          // Se il tasto ha gi√† un comando associato e viene cliccato con Ctrl/Cmd, invia il comando
          if (event && (event.ctrlKey || event.metaKey) && btn.command) {
            sendRemoteCommand(btn.command);
            return;
          }

          if (dom.selectedButtonName) {
            dom.selectedButtonName.textContent = btn.label;
          }

          if (dom.bindingPanel) {
            dom.bindingPanel.style.display = "block";
          }

          // Highlight selected button
          document.querySelectorAll('.remote-button').forEach(el => {
            el.style.boxShadow = '';
          });
          const selectedEl = document.querySelector(`[data-button-id="${buttonId}"]`);
          if (selectedEl) {
            selectedEl.style.boxShadow = '0 0 0 3px #f39c12';
          }

          // Update bind command select to show current binding
          if (btn.command && dom.bindCommandSelect) {
            dom.bindCommandSelect.value = btn.command;
          } else if (dom.bindCommandSelect) {
            dom.bindCommandSelect.value = "";
          }
        };

        async function sendRemoteCommand(commandName) {
          if (!state.customRemote.sourceDevice || !commandName) {
            showToast("Comando non valido", "error");
            return;
          }

          const deviceCommands = state.ir.devices[state.customRemote.sourceDevice];
          if (!deviceCommands || !deviceCommands[commandName]) {
            showToast(`Comando "${commandName}" non trovato`, "error");
            return;
          }

          const commandData = deviceCommands[commandName];

          try {
            const response = await fetch("/special_action", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                actionId: "send_ir_payload",
                params: {
                  label: `${state.customRemote.sourceDevice}_${commandName}`,
                  command: commandData
                }
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error("[CUSTOM REMOTE] Server response:", errorText);
              throw new Error("Failed to send IR command");
            }

            // Visual feedback
            const selectedEl = document.querySelector(`[data-button-id="${state.customRemote.selectedButton}"]`);
            if (selectedEl) {
              const originalBg = selectedEl.style.backgroundColor;
              selectedEl.style.backgroundColor = '#27ae60';
              setTimeout(() => {
                selectedEl.style.backgroundColor = originalBg;
              }, 200);
            }

            showToast(`Comando "${commandName}" inviato!`, "success");
          } catch (error) {
            console.error("[CUSTOM REMOTE] Error sending IR command:", error);
            showToast("Errore invio comando IR", "error");
          }
        }

        function updateBindCommandSelect() {
          if (!dom.bindCommandSelect || !state.customRemote.sourceDevice) return;

          const deviceCommands = state.ir.devices[state.customRemote.sourceDevice];
          if (!deviceCommands) {
            dom.bindCommandSelect.innerHTML = '<option value="">-- Nessun comando disponibile --</option>';
            return;
          }

          let html = '<option value="">-- Seleziona comando --</option>';
          Object.keys(deviceCommands).forEach(cmdName => {
            html += `<option value="${cmdName}">${cmdName}</option>`;
          });

          dom.bindCommandSelect.innerHTML = html;
        }

        function bindCommandToButton() {
          if (!state.customRemote.selectedButton) {
            showToast("Seleziona prima un tasto del telecomando", "error");
            return;
          }

          const command = dom.bindCommandSelect.value;
          if (!command) {
            showToast("Seleziona un comando IR da associare", "error");
            return;
          }

          const btn = state.customRemote.buttons[state.customRemote.selectedButton];
          btn.command = command;

          showToast(`Comando "${command}" associato a ${btn.label}`, "success");
          renderRemotePreview();
        }

        function unbindCommandFromButton() {
          if (!state.customRemote.selectedButton) {
            showToast("Seleziona prima un tasto del telecomando", "error");
            return;
          }

          const btn = state.customRemote.buttons[state.customRemote.selectedButton];
          btn.command = null;

          if (dom.bindCommandSelect) {
            dom.bindCommandSelect.value = "";
          }

          showToast(`Comando rimosso da ${btn.label}`, "success");
          renderRemotePreview();
        }

        async function learnNewCommand() {
          if (!state.customRemote.selectedButton) {
            showToast("Seleziona prima un tasto del telecomando", "error");
            return;
          }

          if (!state.customRemote.sourceDevice) {
            showToast("Nessun dispositivo sorgente selezionato", "error");
            return;
          }

          const btn = state.customRemote.buttons[state.customRemote.selectedButton];
          const commandName = btn.label.toLowerCase().replace(/[^a-z0-9_]/g, '_');

          // Disabilita il pulsante durante l'apprendimento
          if (dom.learnCommandBtn) {
            dom.learnCommandBtn.disabled = true;
            dom.learnCommandBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> In attesa IR...';
          }

          showToast(`Punta il telecomando e premi il tasto per ${btn.label}`, "info");

          // Salva il processore originale
          const originalProcessor = window.customRemoteLearnHandler || null;
          let learningTimeout;

          // Crea un handler globale per l'apprendimento IR
          window.customRemoteLearnHandler = function(irData) {
            console.log("[CUSTOM REMOTE] IR code received for learning:", irData);

            clearTimeout(learningTimeout);
            state.customRemote.learningActive = false;

            // Ripristina il pulsante
            if (dom.learnCommandBtn) {
              dom.learnCommandBtn.disabled = false;
              dom.learnCommandBtn.innerHTML = '<i class="fas fa-satellite-dish"></i>Impara nuovo comando';
            }

            // Assicurati che il dispositivo sorgente esista
            if (!state.ir.devices[state.customRemote.sourceDevice]) {
              state.ir.devices[state.customRemote.sourceDevice] = {};
            }

            // Crea l'oggetto comando
            const commandObj = {
              protocol: irData.protocol,
              bits: irData.bits
            };

            if (irData.value !== undefined && irData.value !== null) {
              commandObj.value = irData.value;
            }

            if (irData.raw && irData.raw.length > 0) {
              commandObj.raw = irData.raw;
            }

            // Salva il comando
            state.ir.devices[state.customRemote.sourceDevice][commandName] = commandObj;
            markIrDirty();

            console.log("[CUSTOM REMOTE] Command saved:", commandName, commandObj);

            // Associa automaticamente il comando al tasto
            btn.command = commandName;

            // Aggiorna UI
            updateBindCommandSelect();
            renderRemotePreview();

            // Rimuovi il handler
            window.customRemoteLearnHandler = null;

            showToast(`Comando "${commandName}" appreso e associato a ${btn.label}!`, "success");

            // Disattiva lo scan mode
            stopScanMode();
          };

          // Attiva flag di apprendimento
          state.customRemote.learningActive = true;

          // Timeout di 15 secondi
          learningTimeout = setTimeout(() => {
            if (state.customRemote.learningActive) {
              console.log("[CUSTOM REMOTE] Learning timeout");
              state.customRemote.learningActive = false;
              window.customRemoteLearnHandler = null;

              if (dom.learnCommandBtn) {
                dom.learnCommandBtn.disabled = false;
                dom.learnCommandBtn.innerHTML = '<i class="fas fa-satellite-dish"></i>Impara nuovo comando';
              }

              showToast("Timeout - nessun segnale IR ricevuto", "error");
              stopScanMode();
            }
          }, 15000);

          // Attiva lo scan mode sul firmware
          try {
            const response = await fetch("/special_action", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                actionId: "toggle_ir_scan",
                params: { active: true }
              })
            });

            if (!response.ok) {
              throw new Error("Failed to activate IR scan mode");
            }

            console.log("[CUSTOM REMOTE] IR scan mode activated for learning");
          } catch (error) {
            console.error("[CUSTOM REMOTE] Error activating IR scan:", error);
            clearTimeout(learningTimeout);
            state.customRemote.learningActive = false;
            window.customRemoteLearnHandler = null;

            if (dom.learnCommandBtn) {
              dom.learnCommandBtn.disabled = false;
              dom.learnCommandBtn.innerHTML = '<i class="fas fa-satellite-dish"></i>Impara nuovo comando';
            }

            showToast("Errore attivazione ricevitore IR", "error");
          }
        }

        function addCustomRemoteButton() {
          const buttonName = window.prompt("Nome del nuovo tasto:");
          if (!buttonName) return;

          const buttonId = "custom_" + Date.now();
          const maxRow = Math.max(...Object.values(state.customRemote.buttons).map(b => b.row || 0), 0);

          state.customRemote.buttons[buttonId] = {
            id: buttonId,
            label: buttonName,
            icon: "fa-circle",
            color: "#95a5a6",
            row: maxRow + 1,
            command: null
          };

          renderRemotePreview();
          showToast(`Tasto "${buttonName}" aggiunto`, "success");
        }

        function resetRemoteLayout() {
          if (!window.confirm("Ripristinare il layout predefinito? Perderai tutti i binding correnti.")) {
            return;
          }

          const layout = REMOTE_LAYOUTS[state.customRemote.remoteType];
          if (layout) {
            state.customRemote.buttons = {};
            layout.buttons.forEach(btn => {
              state.customRemote.buttons[btn.id] = {
                ...btn,
                command: null
              };
            });
            renderRemotePreview();
            showToast("Layout ripristinato", "success");
          }
        }

        function saveRemoteConfiguration() {
          if (!state.customRemote.currentRemote) {
            showToast("Nessun telecomando da salvare", "error");
            return;
          }

          // Save button bindings to current remote
          state.customRemote.currentRemote.buttons = {};
          Object.entries(state.customRemote.buttons).forEach(([id, btn]) => {
            if (btn.command) {
              state.customRemote.currentRemote.buttons[id] = {
                label: btn.label,
                command: btn.command,
                icon: btn.icon,
                color: btn.color,
                row: btn.row
              };
            }
          });

          // Add to saved remotes
          const existingIndex = state.customRemote.savedRemotes.findIndex(
            r => r.name === state.customRemote.currentRemote.name
          );

          if (existingIndex >= 0) {
            state.customRemote.savedRemotes[existingIndex] = state.customRemote.currentRemote;
          } else {
            state.customRemote.savedRemotes.push(state.customRemote.currentRemote);
          }

          // Save to localStorage
          try {
            localStorage.setItem('customRemotes', JSON.stringify(state.customRemote.savedRemotes));
            showToast("Telecomando salvato localmente", "success");
            renderSavedRemotesList();
          } catch (e) {
            showToast("Errore nel salvataggio: " + e.message, "error");
          }
        }

        function loadRemoteConfiguration() {
          try {
            const saved = localStorage.getItem('customRemotes');
            if (!saved) {
              showToast("Nessun telecomando salvato", "info");
              return;
            }

            state.customRemote.savedRemotes = JSON.parse(saved);
            renderSavedRemotesList();
            showToast("Configurazioni caricate", "success");
          } catch (e) {
            showToast("Errore nel caricamento: " + e.message, "error");
          }
        }

        function renderSavedRemotesList() {
          if (!dom.savedRemotesList) return;

          if (state.customRemote.savedRemotes.length === 0) {
            dom.savedRemotesList.innerHTML = '<div class="muted">Nessun telecomando salvato. Crea il tuo primo telecomando!</div>';
            return;
          }

          let html = '';
          state.customRemote.savedRemotes.forEach((remote, index) => {
            const buttonCount = Object.keys(remote.buttons).length;
            html += `
              <div class="list-item" onclick="loadSavedRemote(${index})">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <strong><i class="fas fa-gamepad"></i> ${remote.name}</strong>
                    <div class="muted" style="font-size: 0.8rem;">
                      Tipo: ${REMOTE_LAYOUTS[remote.type]?.name || remote.type} |
                      Device: ${remote.sourceDevice} |
                      Tasti: ${buttonCount}
                    </div>
                  </div>
                  <button class="danger-btn" style="padding: 6px 12px; font-size: 0.8rem;" onclick="event.stopPropagation(); deleteSavedRemote(${index})">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              </div>
            `;
          });

          dom.savedRemotesList.innerHTML = html;
        }

        window.loadSavedRemote = function(index) {
          const remote = state.customRemote.savedRemotes[index];
          if (!remote) return;

          state.customRemote.currentRemote = JSON.parse(JSON.stringify(remote));
          state.customRemote.remoteType = remote.type;
          state.customRemote.sourceDevice = remote.sourceDevice;
          state.customRemote.buttons = {};

          // Load layout
          const layout = REMOTE_LAYOUTS[remote.type];
          if (layout) {
            layout.buttons.forEach(btn => {
              state.customRemote.buttons[btn.id] = {
                ...btn,
                command: remote.buttons[btn.id]?.command || null
              };
            });
          }

          // Load custom buttons
          Object.entries(remote.buttons).forEach(([id, btn]) => {
            if (!state.customRemote.buttons[id]) {
              state.customRemote.buttons[id] = {
                id: id,
                label: btn.label,
                icon: btn.icon,
                color: btn.color,
                row: btn.row,
                command: btn.command
              };
            }
          });

          dom.remoteType.value = remote.type;
          dom.remoteDeviceSelect.value = remote.sourceDevice;
          dom.remoteBuilderContainer.style.display = "block";
          dom.saveRemoteBtn.disabled = false;

          updateRemoteTypeName();
          renderRemotePreview();
          updateBindCommandSelect();
          showToast(`Telecomando "${remote.name}" caricato`, "success");
        };

        window.deleteSavedRemote = function(index) {
          if (!window.confirm("Eliminare questo telecomando salvato?")) return;

          state.customRemote.savedRemotes.splice(index, 1);
          localStorage.setItem('customRemotes', JSON.stringify(state.customRemote.savedRemotes));
          renderSavedRemotesList();
          showToast("Telecomando eliminato", "success");
        };

        function syncRemoteDeviceSelect() {
          if (!dom.remoteDeviceSelect) return;

          const deviceNames = Object.keys(state.ir.devices).sort();
          let html = '<option value="">-- Seleziona dispositivo --</option>';
          deviceNames.forEach(name => {
            html += `<option value="${name}">${name}</option>`;
          });

          dom.remoteDeviceSelect.innerHTML = html;
        }

        // ========== END CUSTOM REMOTE CONTROL FUNCTIONS ==========

        function setupEventHandlers() {
          if (dom.actionContainer) {
            dom.actionContainer.addEventListener("click", handleActionContainerClick);
          }
          if (dom.reloadActions) {
            dom.reloadActions.addEventListener("click", () => loadActionCatalog(true));
          }
          if (dom.logsReconnect) {
            dom.logsReconnect.addEventListener("click", setupLogs);
          }
          if (dom.logsClear && dom.logStream) {
            dom.logsClear.addEventListener("click", () => {
              dom.logStream.innerHTML = "";
            });
          }
          if (dom.irReloadLocal) {
            dom.irReloadLocal.addEventListener("click", () => loadLocalIrData(true));
          }
          if (dom.irDeviceSelect) {
            dom.irDeviceSelect.addEventListener("change", (event) => {
              state.ir.selectedDevice = event.target.value;
              renderLocalCommands();
            });
          }
          if (dom.irAddDevice) {
            dom.irAddDevice.addEventListener("click", () => {
              const name = window.prompt("Nome nuovo dispositivo?");
              const sanitized = sanitizeDeviceName(name);
              if (!sanitized) {
                showToast("Nome dispositivo non valido.", "error");
                return;
              }
              if (state.ir.devices[sanitized]) {
                showToast("Dispositivo gi√† esistente.", "error");
                return;
              }
              state.ir.devices[sanitized] = {};
              state.ir.selectedDevice = sanitized;
              markIrDirty();
              syncDeviceSelects();
              renderLocalCommands();
              showToast(`Dispositivo ${sanitized} creato.`, "success");
            });
          }
          if (dom.irRenameDevice) {
            dom.irRenameDevice.addEventListener("click", () => {
              if (!state.ir.selectedDevice) {
                showToast("Nessun dispositivo selezionato.", "error");
                return;
              }
              const newName = window.prompt("Nuovo nome", state.ir.selectedDevice);
              const sanitized = sanitizeDeviceName(newName);
              if (!sanitized) {
                showToast("Nome dispositivo non valido.", "error");
                return;
              }
              if (state.ir.devices[sanitized]) {
                showToast("Nome gi√† in uso.", "error");
                return;
              }
              state.ir.devices[sanitized] = state.ir.devices[state.ir.selectedDevice];
              delete state.ir.devices[state.ir.selectedDevice];
              state.ir.selectedDevice = sanitized;
              markIrDirty();
              syncDeviceSelects();
              renderLocalCommands();
              showToast("Dispositivo rinominato.", "success");
            });
          }
          if (dom.irDeleteDevice) {
            dom.irDeleteDevice.addEventListener("click", () => {
              if (!state.ir.selectedDevice) {
                showToast("Nessun dispositivo selezionato.", "error");
                return;
              }
              if (!window.confirm(`Eliminare il dispositivo ${state.ir.selectedDevice}?`)) {
                return;
              }
              delete state.ir.devices[state.ir.selectedDevice];
              state.ir.selectedDevice = "";
              markIrDirty();
              syncDeviceSelects();
              renderLocalCommands();
              showToast("Dispositivo eliminato.", "success");
            });
          }
          if (dom.irSaveChanges) {
            dom.irSaveChanges.addEventListener("click", saveIrData);
          }
          if (dom.irdbLoadIndex) {
            dom.irdbLoadIndex.addEventListener("click", () => loadIrdbIndex(true));
          }
          if (dom.irdbSearchInput) {
            dom.irdbSearchInput.addEventListener("input", (event) => {
              filterIrdbResults(event.target.value || "");
            });
          }
          if (dom.irdbResults) {
            dom.irdbResults.addEventListener("click", handleIrdbResultClick);
          }
          if (dom.irdbCommandsContainer) {
            dom.irdbCommandsContainer.addEventListener("change", handleIrdbSelectionChange);
            dom.irdbCommandsContainer.addEventListener("click", handleIrdbCommandActions);
          }
          if (dom.irdbImportSelected) {
            dom.irdbImportSelected.addEventListener("click", importSelectedIrdbCommands);
          }
          if (dom.guidedLoadIndex) {
            dom.guidedLoadIndex.addEventListener("click", () => loadIrdbIndex(true));
          }
          if (dom.guidedDeviceType) {
            dom.guidedDeviceType.addEventListener("change", (event) => {
              state.guided.deviceType = event.target.value;
              updateGuidedBrandOptions();
            });
          }
          if (dom.guidedBrand) {
            dom.guidedBrand.addEventListener("change", (event) => {
              state.guided.brand = event.target.value || "";
              updateGuidedStartButtonState();
            });
          }
          if (dom.guidedTargetDevice) {
            dom.guidedTargetDevice.addEventListener("change", (event) => {
              state.guided.targetDevice = sanitizeDeviceName(event.target.value);
              updateGuidedStartButtonState();
            });
          }
          if (dom.guidedNewDevice) {
            dom.guidedNewDevice.addEventListener("input", () => updateGuidedStartButtonState());
          }
          if (dom.guidedStart) {
            dom.guidedStart.addEventListener("click", startGuidedMode);
          }
          if (dom.guidedStop) {
            dom.guidedStop.addEventListener("click", () =>
              stopGuidedMode("Procedura annullata.", "info")
            );
          }
          if (dom.guidedFeedbackYes) {
            dom.guidedFeedbackYes.addEventListener("click", () => handleGuidedFeedback("yes"));
          }
          if (dom.guidedFeedbackNo) {
            dom.guidedFeedbackNo.addEventListener("click", () => handleGuidedFeedback("no"));
          }
          if (dom.guidedFeedbackSkip) {
            dom.guidedFeedbackSkip.addEventListener("click", () => handleGuidedFeedback("skip"));
          }
          if (dom.identifyFromScan) {
            dom.identifyFromScan.addEventListener("click", identifyDeviceFromScan);
          }
          if (dom.identifyFromProfile) {
            dom.identifyFromProfile.addEventListener("click", identifyDeviceFromProfile);
          }
          if (dom.identificationResults) {
            dom.identificationResults.addEventListener("click", handleIdentificationResultClick);
          }
          if (dom.startScanMode) {
            console.log("[IR SCAN] Attaching event listener to startScanMode button");
            dom.startScanMode.addEventListener("click", startScanMode);
          } else {
            console.error("[IR SCAN] startScanMode button not found in DOM!");
          }
          if (dom.stopScanMode) {
            console.log("[IR SCAN] Attaching event listener to stopScanMode button");
            dom.stopScanMode.addEventListener("click", stopScanMode);
          } else {
            console.error("[IR SCAN] stopScanMode button not found in DOM!");
          }
          if (dom.clearScannedCodes) {
            console.log("[IR SCAN] Attaching event listener to clearScannedCodes button");
            dom.clearScannedCodes.addEventListener("click", clearScannedCodes);
          } else {
            console.error("[IR SCAN] clearScannedCodes button not found in DOM!");
          }
          if (dom.saveScannedCodes) {
            console.log("[IR SCAN] Attaching event listener to saveScannedCodes button");
            dom.saveScannedCodes.addEventListener("click", saveScannedCodes);
          } else {
            console.error("[IR SCAN] saveScannedCodes button not found in DOM!");
          }
          if (dom.scannedCodesContainer) {
            console.log("[IR SCAN] Attaching event listener to scannedCodesContainer");
            dom.scannedCodesContainer.addEventListener("click", handleScannedCodeAction);
          } else {
            console.error("[IR SCAN] scannedCodesContainer not found in DOM!");
          }
          if (dom.scanTargetDevice) {
            console.log("[IR SCAN] Attaching event listener to scanTargetDevice select");
            dom.scanTargetDevice.addEventListener("change", (event) => {
              console.log("[IR SCAN] Device selection changed:", event.target.value);
              state.irScan.targetDevice = event.target.value;
            });
          } else {
            console.error("[IR SCAN] scanTargetDevice select not found in DOM!");
          }

          // Custom Remote event handlers
          if (dom.createRemoteBtn) {
            dom.createRemoteBtn.addEventListener("click", createNewRemote);
          }
          if (dom.loadRemoteBtn) {
            dom.loadRemoteBtn.addEventListener("click", loadRemoteConfiguration);
          }
          if (dom.saveRemoteBtn) {
            dom.saveRemoteBtn.addEventListener("click", saveRemoteConfiguration);
          }
          if (dom.addCustomButton) {
            dom.addCustomButton.addEventListener("click", addCustomRemoteButton);
          }
          if (dom.resetRemoteLayout) {
            dom.resetRemoteLayout.addEventListener("click", resetRemoteLayout);
          }
          if (dom.bindCommandBtn) {
            dom.bindCommandBtn.addEventListener("click", bindCommandToButton);
          }
          if (dom.testRemoteCommandBtn) {
            dom.testRemoteCommandBtn.addEventListener("click", () => {
              if (!state.customRemote.selectedButton) {
                showToast("Seleziona un tasto prima", "error");
                return;
              }
              const btn = state.customRemote.buttons[state.customRemote.selectedButton];
              if (!btn.command) {
                showToast("Questo tasto non ha un comando associato", "error");
                return;
              }
              sendRemoteCommand(btn.command);
            });
          }
          if (dom.unbindCommandBtn) {
            dom.unbindCommandBtn.addEventListener("click", unbindCommandFromButton);
          }
          if (dom.learnCommandBtn) {
            dom.learnCommandBtn.addEventListener("click", learnNewCommand);
          }
          if (dom.remoteType) {
            dom.remoteType.addEventListener("change", updateRemoteTypeName);
          }
          if (dom.remoteDeviceSelect) {
            dom.remoteDeviceSelect.addEventListener("change", (e) => {
              state.customRemote.sourceDevice = e.target.value;
              updateBindCommandSelect();
            });
          }

          updateGuidedBrandOptions();
          renderGuidedHistory();
          updateGuidedStartButtonState();
        }

        function init() {
          if (!supportsFetch) {
            showToast("Browser non supporta la Fetch API. Aggiorna o prova un altro browser.", "error");
          }
          setupTabs();
          setupEventHandlers();
          loadActionCatalog();
          setupLogs();
          updateIrDirtyUI();
          loadTestResultsFromLocalStorage();
          loadRemoteConfiguration();
          renderSavedRemotesList();
        }

        document.addEventListener("DOMContentLoaded", init);
        window.addEventListener("beforeunload", () => {
          if (state.eventSource) {
            state.eventSource.close();
          }
        });
        } catch (error) {
          console.error("[SpecialActions] Fatal error:", error);
          const toast = document.getElementById("toast");
          if (toast) {
            toast.textContent = "Errore di inizializzazione interfaccia.";
            toast.className = "toast show error";
          }
        }
      })();
    </script>
  </body>
</html>
