#include "GyroMouse.h"
#include "Logger.h"
#include "BLEController.h"
#include "InputHub.h"

#include <cmath>

namespace
{
    constexpr float kRateScaleFactor = 0.5f * 100.0f; // Empirical °/s -> px factor
    constexpr float kRadToDeg = 57.2957795f;
    constexpr float kDegToRad = 1.0f / kRadToDeg;
    constexpr float kNeutralCaptureGyroThreshold = 0.08f; // rad/s (~4.6°/s) - balanced threshold
    constexpr uint16_t kNeutralCaptureSampleTarget = 50; // balanced sample count
    constexpr float kNeutralCaptureVarianceThreshold = 0.005f; // more permissive variance threshold
}

// Riferimento esterno al BLE controller
extern BLEController bleController;
extern InputHub inputHub;

GyroMouse::GyroMouse()
    : gestureSensor(nullptr),
      active(false),
      currentSensitivityIndex(1),
      config(),
      ownsSampling(false),
      gestureCaptureSuspended(false),
      gyroAvailable(false),
      smoothedMouseX(0.0f),
      smoothedMouseY(0.0f),
      residualMouseX(0.0f),
      residualMouseY(0.0f),
      lastUpdateTime(0),
      clickSlowdownFactor(1.0f),
      lastClickCheckTime(0),
      neutralCapturePending(false),
      neutralCaptureSamples(0),
      neutralPitchAccum(0.0f),
      neutralRollAccum(0.0f),
      gyroBiasAccumX(0.0f),
      gyroBiasAccumY(0.0f),
      gyroBiasAccumZ(0.0f),
      gyroBiasSquaredAccumX(0.0f),
      gyroBiasSquaredAccumY(0.0f),
      gyroBiasSquaredAccumZ(0.0f) {
}

GyroMouse::~GyroMouse() {
    stop();
}

bool GyroMouse::begin(GestureRead* sensor, const GyroMouseConfig& cfg) {
    if (!sensor) {
        Logger::getInstance().log("GyroMouse: Invalid sensor pointer");
        return false;
    }

    gestureSensor = sensor;
    config = cfg;

    SensorFusionConfig fusionConfig;
    fusionConfig.smoothing = config.smoothing;
    fusionConfig.orientationAlpha = config.orientationAlpha;
    fusion.begin(fusionConfig);

    active = false;
    ownsSampling = false;
    gestureCaptureSuspended = false;

    if (config.sensitivities.empty()) {
        Logger::getInstance().log("GyroMouse: No sensitivity settings defined");
        return false;
    }

    if (config.defaultSensitivity < config.sensitivities.size()) {
        currentSensitivityIndex = config.defaultSensitivity;
    } else {
        currentSensitivityIndex = 0;
        Logger::getInstance().log("GyroMouse: Invalid default sensitivity, using 0");
    }

    Logger::getInstance().log("GyroMouse: Initialized with " +
                             String(config.sensitivities.size()) + " sensitivity modes");
    return true;
}

void GyroMouse::start() {
    if (!config.enabled) {
        Logger::getInstance().log("GyroMouse: Disabled in config");
        return;
    }

    if (!gestureSensor) {
        Logger::getInstance().log("GyroMouse: Sensor not available");
        return;
    }

    if (!bleController.isBleEnabled()) {
        Logger::getInstance().log("GyroMouse: BLE disabled, cannot start");
        return;
    }

    if (active) {
        Logger::getInstance().log("GyroMouse: Already active");
        return;
    }

    gestureSensor->setStreamingMode(true);

    if (inputHub.isGestureCaptureEnabled()) {
        inputHub.setGestureCaptureEnabled(false);
        gestureCaptureSuspended = true;
    } else {
        gestureCaptureSuspended = false;
    }

    ownsSampling = false;
    if (!gestureSensor->isSampling()) {
        if (!gestureSensor->startSampling()) {
            Logger::getInstance().log("GyroMouse: Failed to start sensor sampling");
            if (gestureCaptureSuspended) {
                inputHub.setGestureCaptureEnabled(true);
                gestureCaptureSuspended = false;
            }
            gestureSensor->setStreamingMode(false);
            return;
        }
        ownsSampling = true;
    }

    gestureSensor->clearMemory();

    gyroAvailable = gestureSensor->getMotionSensor() &&
                    gestureSensor->getMotionSensor()->hasGyro();

    fusion.reset();
    beginNeutralCapture();
    Logger::getInstance().log("GyroMouse: Neutral capture requested");
    lastUpdateTime = millis();

    active = true;

    String sensName = config.sensitivities[currentSensitivityIndex].name;
    Logger::getInstance().log("GyroMouse: Started (sensitivity: " + sensName + ")");
}

void GyroMouse::stop() {
    if (!active) {
        return;
    }

    active = false;
    smoothedMouseX = 0.0f;
    smoothedMouseY = 0.0f;
    residualMouseX = 0.0f;
    residualMouseY = 0.0f;
    neutralCapturePending = false;
    neutralCaptureSamples = 0;
    neutralPitchAccum = 0.0f;
    neutralRollAccum = 0.0f;
    gyroBiasAccumX = 0.0f;
    gyroBiasAccumY = 0.0f;
    gyroBiasAccumZ = 0.0f;
    gyroBiasSquaredAccumX = 0.0f;
    gyroBiasSquaredAccumY = 0.0f;
    gyroBiasSquaredAccumZ = 0.0f;
    gyroAvailable = false;

    if (ownsSampling && gestureSensor) {
        gestureSensor->ensureMinimumSamplingTime();
        gestureSensor->stopSampling();
        gestureSensor->clearMemory();
        gestureSensor->flushSensorBuffer();
    }
    ownsSampling = false;

    if (gestureCaptureSuspended) {
        inputHub.setGestureCaptureEnabled(true);
        gestureCaptureSuspended = false;
    }

    if (gestureSensor) {
        gestureSensor->setStreamingMode(false);
    }

    Logger::getInstance().log("GyroMouse: Stopped");
}

void GyroMouse::update() {
    if (!active || !gestureSensor) {
        return;
    }

    unsigned long currentTime = millis();
    float deltaTime = (currentTime - lastUpdateTime) / 1000.0f;
    lastUpdateTime = currentTime;

    if (deltaTime > 0.1f || deltaTime <= 0.0f) {
        deltaTime = 0.005f; // Assume 200Hz
    }

    SensorFrame frame{};
    frame.gyroX = gestureSensor->getMappedGyroX();
    frame.gyroY = gestureSensor->getMappedGyroY();
    frame.gyroZ = gestureSensor->getMappedGyroZ();
    frame.accelX = gestureSensor->getMappedX();
    frame.accelY = gestureSensor->getMappedY();
    frame.accelZ = gestureSensor->getMappedZ();
    frame.accelMagnitude = sqrtf(frame.accelX * frame.accelX +
                                 frame.accelY * frame.accelY +
                                 frame.accelZ * frame.accelZ);
    frame.gyroValid = gyroAvailable;

    fusion.update(frame, deltaTime);

    if (neutralCapturePending) {
        float pitchAcc = atan2f(-frame.accelX, sqrtf(frame.accelY * frame.accelY + frame.accelZ * frame.accelZ));
        float rollAcc = atan2f(frame.accelY, frame.accelZ);
        accumulateNeutralCapture(pitchAcc, rollAcc, frame);
    }

    if (!fusion.hasNeutralOrientation()) {
        smoothedMouseX = 0.0f;
        smoothedMouseY = 0.0f;
        residualMouseX = 0.0f;
        residualMouseY = 0.0f;
        return;
    }

    updateClickSlowdown();

    int8_t mouseX = 0;
    int8_t mouseY = 0;

    if (gyroAvailable) {
        calculateMouseMovement(frame, deltaTime, mouseX, mouseY);
    }

    if (clickSlowdownFactor < 1.0f) {
        mouseX = static_cast<int8_t>(mouseX * clickSlowdownFactor);
        mouseY = static_cast<int8_t>(mouseY * clickSlowdownFactor);
    }

    if (mouseX != 0 || mouseY != 0) {
        bleController.moveMouse(mouseX, mouseY, 0, 0);
    }
}

void GyroMouse::calculateMouseMovement(const SensorFrame& frame, float deltaTime,
                                       int8_t& mouseX, int8_t& mouseY) {
    if (!fusion.hasNeutralOrientation() || config.sensitivities.empty()) {
        mouseX = 0;
        mouseY = 0;
        return;
    }

    const SensitivitySettings& sens = config.sensitivities[currentSensitivityIndex];
    const float rateScale = sens.gyroScale > 0.0f ? sens.gyroScale : sens.scale;

    Quaternion relativeRotation = fusion.getRelativeOrientation();

    // Extract Euler angles from relative orientation
    float pitch, roll, yaw;
    relativeRotation.toEuler(pitch, roll, yaw);

    // Get previous Euler angles (for rate calculation)
    static float lastPitch = 0.0f;
    static float lastRoll = 0.0f;
    static float lastYaw = 0.0f;

    // Calculate angular velocities from Euler angle changes (deg/s)
    // This gives us screen-aligned motion even when device is rotated
    float pitchRate = (pitch - lastPitch) * kRadToDeg / deltaTime;
    float rollRate = (roll - lastRoll) * kRadToDeg / deltaTime;
    float yawRate = (yaw - lastYaw) * kRadToDeg / deltaTime;

    // Handle yaw wraparound (180° -> -180° discontinuity)
    if (fabsf(yawRate) > 180.0f / deltaTime) {
        yawRate = 0.0f; // Ignore wraparound spikes
    }

    // Store for next frame
    lastPitch = pitch;
    lastRoll = roll;
    lastYaw = yaw;

    // Map to screen axes (intuitive control):
    // - Yaw left/right -> cursor left/right
    // - Pitch up/down -> cursor up/down
    float rateX = applyDynamicDeadzone(yawRate, sens.deadzone,
                                       fusion.getFilterState().gyroNoiseEstimate * kRadToDeg);
    float rateY = applyDynamicDeadzone(-pitchRate, sens.deadzone,
                                       fusion.getFilterState().gyroNoiseEstimate * kRadToDeg);

    // Apply acceleration curve
    rateX = applyAccelerationCurve(rateX, sens.accelerationCurve);
    rateY = applyAccelerationCurve(rateY, sens.accelerationCurve);

    // Convert rate to pixel movement
    float rawMouseX = rateX * rateScale * deltaTime * kRateScaleFactor;
    float rawMouseY = rateY * rateScale * deltaTime * kRateScaleFactor;

    bool invertX = config.invertX;
    bool invertY = config.invertY;
    bool swapAxes = config.swapAxes;

    if (sens.swapAxesOverride >= 0) {
        swapAxes = sens.swapAxesOverride > 0;
    }
    if (sens.invertXOverride >= 0) {
        invertX = sens.invertXOverride > 0;
    }
    if (sens.invertYOverride >= 0) {
        invertY = sens.invertYOverride > 0;
    }

    if (swapAxes) {
        float temp = rawMouseX;
        rawMouseX = rawMouseY;
        rawMouseY = temp;
    }
    if (invertX) rawMouseX = -rawMouseX;
    if (invertY) rawMouseY = -rawMouseY;

    float currentSmoothFactor = constrain(fusion.getFilterState().adaptiveSmoothingFactor, 0.0f, 0.95f);

    auto applySmoothing = [&](float rawValue, float& smoothValue, float& residualValue) -> int8_t {
        if (currentSmoothFactor <= 0.0f) {
            smoothValue = rawValue;
        } else {
            smoothValue += (rawValue - smoothValue) * currentSmoothFactor;
        }
        float pending = (currentSmoothFactor <= 0.0f ? rawValue : smoothValue) + residualValue;
        return clampMouseValue(pending, residualValue);
    };

    mouseX = applySmoothing(rawMouseX, smoothedMouseX, residualMouseX);
    mouseY = applySmoothing(rawMouseY, smoothedMouseY, residualMouseY);
}

void GyroMouse::recenterNeutral() {
    if (!gestureSensor) {
        Logger::getInstance().log("GyroMouse: recenter ignored (sensor unavailable)");
        return;
    }

    performAbsoluteCentering();

    beginNeutralCapture();

    Logger::getInstance().log("GyroMouse: Neutral capture requested");
}

int8_t GyroMouse::clampMouseValue(float pending, float& residual) {
    float rounded = roundf(pending);

    if (rounded > 127.0f) {
        residual = 0.0f;
        return 127;
    }
    if (rounded < -127.0f) {
        residual = 0.0f;
        return -127;
    }

    const float reported = static_cast<float>(rounded);
    residual = pending - reported;
    return static_cast<int8_t>(rounded);
}

void GyroMouse::beginNeutralCapture() {
    fusion.reset();
    neutralCapturePending = true;
    neutralCaptureSamples = 0;
    neutralPitchAccum = 0.0f;
    neutralRollAccum = 0.0f;
    gyroBiasAccumX = 0.0f;
    gyroBiasAccumY = 0.0f;
    gyroBiasAccumZ = 0.0f;
    gyroBiasSquaredAccumX = 0.0f;
    gyroBiasSquaredAccumY = 0.0f;
    gyroBiasSquaredAccumZ = 0.0f;
    smoothedMouseX = 0.0f;
    smoothedMouseY = 0.0f;
    residualMouseX = 0.0f;
    residualMouseY = 0.0f;
}

void GyroMouse::cycleSensitivity() {
    currentSensitivityIndex = (currentSensitivityIndex + 1) % config.sensitivities.size();

    smoothedMouseX = 0.0f;
    smoothedMouseY = 0.0f;
    residualMouseX = 0.0f;
    residualMouseY = 0.0f;

    beginNeutralCapture();

    String sensName = config.sensitivities[currentSensitivityIndex].name;
    Logger::getInstance().log("GyroMouse: Sensitivity changed to " + sensName);
}

String GyroMouse::getSensitivityName() const {
    if (currentSensitivityIndex < config.sensitivities.size()) {
        return config.sensitivities[currentSensitivityIndex].name;
    }
    return "unknown";
}

void GyroMouse::updateClickSlowdown() {
    unsigned long currentTime = millis();
    if (currentTime - lastClickCheckTime < 10) {
        return;
    }
    lastClickCheckTime = currentTime;

    bool anyButtonPressed = bleController.isAnyMouseButtonPressed();

    if (anyButtonPressed) {
        unsigned long timeSinceChange = bleController.getTimeSinceLastMouseButtonChange();
        float baseSlowdown = config.clickSlowdownFactor;

        if (timeSinceChange < 50) {
            clickSlowdownFactor = baseSlowdown * 0.5f;
        } else if (timeSinceChange < 150) {
            clickSlowdownFactor = baseSlowdown * 0.75f;
        } else if (timeSinceChange < 300) {
            clickSlowdownFactor = baseSlowdown;
        } else {
            clickSlowdownFactor = fminf(baseSlowdown * 1.5f, 0.9f);
        }
    } else {
        clickSlowdownFactor = 1.0f;
    }
}

void GyroMouse::performAbsoluteCentering() {
    if (!config.absoluteRecenter) {
        return;
    }

    if (!bleController.isBleEnabled()) {
        return;
    }

    const bool centerX = config.absoluteRangeX > 0;
    const bool centerY = config.absoluteRangeY > 0;

    if (!centerX && !centerY) {
        return;
    }

    const int32_t backX = centerX ? -config.absoluteRangeX : 0;
    const int32_t backY = centerY ? -config.absoluteRangeY : 0;
    if (backX != 0 || backY != 0) {
        dispatchRelativeMove(backX, backY);
    }

    const int32_t halfX = centerX ? ((config.absoluteRangeX + 1) / 2) : 0;
    const int32_t halfY = centerY ? ((config.absoluteRangeY + 1) / 2) : 0;
    if (halfX != 0 || halfY != 0) {
        dispatchRelativeMove(halfX, halfY);
    }

    Logger::getInstance().log("GyroMouse: Absolute pointer recentered");
}

void GyroMouse::dispatchRelativeMove(int deltaX, int deltaY) {
    const int maxStep = 127;
    int iterations = 0;
    const int maxIterations = 50; // Safety limit to prevent infinite loops

    while ((deltaX != 0 || deltaY != 0) && iterations < maxIterations) {
        int stepX = 0;
        if (deltaX > 0) {
            stepX = deltaX > maxStep ? maxStep : deltaX;
        } else if (deltaX < 0) {
            stepX = deltaX < -maxStep ? -maxStep : deltaX;
        }

        int stepY = 0;
        if (deltaY > 0) {
            stepY = deltaY > maxStep ? maxStep : deltaY;
        } else if (deltaY < 0) {
            stepY = deltaY < -maxStep ? -maxStep : deltaY;
        }

        if (stepX == 0 && stepY == 0) {
            break;
        }

        bleController.moveMouse(static_cast<signed char>(stepX),
                                static_cast<signed char>(stepY),
                                0,
                                0);

        deltaX -= stepX;
        deltaY -= stepY;
        iterations++;

        // Yield to system instead of blocking delay
        yield();
        delayMicroseconds(500); // Very short delay for HID stability
    }
}

float GyroMouse::applyDynamicDeadzone(float value, float baseThreshold, float noiseFactor) {
    // Static variables for hysteresis (per-axis state would be better, but this is simpler)
    static bool wasInDeadzoneX = false;
    static bool wasInDeadzoneY = false;
    static float lastValueX = 0.0f;
    static float lastValueY = 0.0f;

    // Determine which axis we're processing based on recent history
    // This is a simple heuristic - in a perfect world we'd track per-axis state
    bool isXAxis = (fabsf(value - lastValueX) < fabsf(value - lastValueY));
    bool& wasInDeadzone = isXAxis ? wasInDeadzoneX : wasInDeadzoneY;
    float& lastValue = isXAxis ? lastValueX : lastValueY;

    lastValue = value;

    // Calculate dynamic threshold based on noise estimate
    float base = fmaxf(baseThreshold, 0.0f);
    float dynamicThreshold = base + noiseFactor * kRadToDeg * 2.5f;  // Increased from 1.2 to 2.5 for better noise rejection

    const float minThreshold = 0.05f;
    if (base <= 0.0f) {
        dynamicThreshold = fmaxf(dynamicThreshold, minThreshold);
    } else {
        dynamicThreshold = constrain(dynamicThreshold, base * 0.6f, base * 2.2f + minThreshold);
        dynamicThreshold = fmaxf(dynamicThreshold, minThreshold);
    }

    // Hysteresis: use lower threshold to exit deadzone (prevents oscillation)
    float activeThreshold = wasInDeadzone ? dynamicThreshold * 0.7f : dynamicThreshold;
    float transitionZone = dynamicThreshold * 1.8f;  // Smooth transition zone

    float absValue = fabsf(value);

    // Check if in deadzone
    if (absValue <= activeThreshold) {
        wasInDeadzone = true;
        return 0.0f;
    }

    wasInDeadzone = false;

    // Smooth transition using cubic ease-out curve
    if (absValue <= transitionZone) {
        // Calculate normalized position in transition zone [0, 1]
        float t = (absValue - activeThreshold) / (transitionZone - activeThreshold);

        // Cubic ease-out: 1 - (1-t)³
        float smoothT = 1.0f - powf(1.0f - t, 3.0f);

        // Map to output range
        float smoothedValue = activeThreshold + smoothT * (transitionZone - activeThreshold);
        return (value >= 0.0f) ? smoothedValue : -smoothedValue;
    }

    // Beyond transition zone - linear response
    return value;
}

float GyroMouse::applyAccelerationCurve(float angularVelocity, float curveExponent) {
    // curveExponent < 1.0: sub-linear (precision mode - slow movements amplified)
    // curveExponent = 1.0: linear (normal mode)
    // curveExponent > 1.0: super-linear (fast mode - quick movements amplified)

    if (fabsf(angularVelocity) < 0.001f) {
        return 0.0f; // Avoid pow() on very small values
    }

    float sign = (angularVelocity >= 0.0f) ? 1.0f : -1.0f;
    float absVelocity = fabsf(angularVelocity);

    // Apply power curve
    float transformed = powf(absVelocity, curveExponent);

    return sign * transformed;
}

void GyroMouse::accumulateNeutralCapture(float pitchAcc, float rollAcc, const SensorFrame& frame) {
    if (!neutralCapturePending) {
        return;
    }

    float gyroX, gyroY, gyroZ;
    fusion.getGyroBias(gyroX, gyroY, gyroZ);

    const float gyroQuietX = fabsf(frame.gyroX - gyroX);
    const float gyroQuietY = fabsf(frame.gyroY - gyroY);
    const float gyroQuietZ = fabsf(frame.gyroZ - gyroZ);

    // Check if gyro is quiet enough - stricter threshold for better stability
    if (gyroQuietX > kNeutralCaptureGyroThreshold ||
        gyroQuietY > kNeutralCaptureGyroThreshold ||
        gyroQuietZ > kNeutralCaptureGyroThreshold) {
        // Movement detected - reset accumulation
        neutralCaptureSamples = 0;
        neutralPitchAccum = 0.0f;
        neutralRollAccum = 0.0f;
        gyroBiasAccumX = 0.0f;
        gyroBiasAccumY = 0.0f;
        gyroBiasAccumZ = 0.0f;
        gyroBiasSquaredAccumX = 0.0f;
        gyroBiasSquaredAccumY = 0.0f;
        gyroBiasSquaredAccumZ = 0.0f;
        return;
    }

    // Accumulate samples for averaging and variance calculation
    neutralPitchAccum += pitchAcc;
    neutralRollAccum += rollAcc;
    gyroBiasAccumX += frame.gyroX;
    gyroBiasAccumY += frame.gyroY;
    gyroBiasAccumZ += frame.gyroZ;

    // Accumulate squared values for variance calculation
    gyroBiasSquaredAccumX += frame.gyroX * frame.gyroX;
    gyroBiasSquaredAccumY += frame.gyroY * frame.gyroY;
    gyroBiasSquaredAccumZ += frame.gyroZ * frame.gyroZ;

    ++neutralCaptureSamples;

    // Need enough samples for reliable capture
    if (neutralCaptureSamples < kNeutralCaptureSampleTarget) {
        return;
    }

    // Calculate variance to ensure stability (variance = E[X²] - E[X]²)
    const float invCount = 1.0f / static_cast<float>(neutralCaptureSamples);
    const float meanX = gyroBiasAccumX * invCount;
    const float meanY = gyroBiasAccumY * invCount;
    const float meanZ = gyroBiasAccumZ * invCount;

    const float varianceX = (gyroBiasSquaredAccumX * invCount) - (meanX * meanX);
    const float varianceY = (gyroBiasSquaredAccumY * invCount) - (meanY * meanY);
    const float varianceZ = (gyroBiasSquaredAccumZ * invCount) - (meanZ * meanZ);
    const float totalVariance = varianceX + varianceY + varianceZ;

    // If variance too high, device is not stable enough - retry
    if (totalVariance > kNeutralCaptureVarianceThreshold) {
        Logger::getInstance().log("GyroMouse: Neutral capture rejected (variance too high: " +
                                  String(totalVariance, 6) + ")");
        neutralCaptureSamples = 0;
        neutralPitchAccum = 0.0f;
        neutralRollAccum = 0.0f;
        gyroBiasAccumX = 0.0f;
        gyroBiasAccumY = 0.0f;
        gyroBiasAccumZ = 0.0f;
        gyroBiasSquaredAccumX = 0.0f;
        gyroBiasSquaredAccumY = 0.0f;
        gyroBiasSquaredAccumZ = 0.0f;
        return;
    }

    // Variance acceptable - update bias with averaged values
    fusion.updateGyroBias(meanX, meanY, meanZ);

    // Capture neutral orientation
    fusion.captureNeutralOrientation();

    neutralCapturePending = false;
    smoothedMouseX = 0.0f;
    smoothedMouseY = 0.0f;
    residualMouseX = 0.0f;
    residualMouseY = 0.0f;
    lastUpdateTime = millis();

    Logger::getInstance().log("GyroMouse: Neutral capture completed (" +
                              String(neutralCaptureSamples) + " samples, variance: " +
                              String(totalVariance, 6) + ")");
    Logger::getInstance().log("GyroMouse: Neutral orientation recentered");
}
